cheatsheetplr = game.Players.LocalPlayer
i = Instance.new("NumberValue", cheatsheetplr )
i.Name = "FPSCH"
Bin = Instance.new("HopperBin", cheatsheetplr .Backpack)
script.Parent = Bin
Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = Player:GetMouse()
NoTarget = Instance.new("Model", Character)
coroutine.resume(coroutine.create(function()
  MMouse.TargetFilter = NoTarget --workspace:WaitForChild("NoTarget")
end))
combo = 0
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local shieldroll = false
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local guard = false
local blocknum = 50
local stance = false
stancetime = 0
local sattack = "None"
doingbust = false
busterhit = false
bustTarget = nil
sbash = false
cangrab = true
move1 = [[
(Z)
Tortoise Shell]]
move2 = [[
(X)
Omega Stance]]
move3 = [[
(C)
Smash]]
move4 = [[
(V)
Buster Slam]]
cooldowns = {}
cooldown1 = 0
table.insert(cooldowns, cooldown1)
cooldown2 = 0
table.insert(cooldowns, cooldown2)
cooldown3 = 0
table.insert(cooldowns, cooldown3)
cooldown4 = 0
table.insert(cooldowns, cooldown4)
cooldownsadd = {}
cooldownadd1 = 0.235
table.insert(cooldownsadd, cooldownadd1)
cooldownadd2 = 0.21
table.insert(cooldownsadd, cooldownadd2)
cooldownadd3 = 0.185
table.insert(cooldownsadd, cooldownadd3)
cooldownadd4 = 0.1
table.insert(cooldownsadd, cooldownadd4)
cooldownmax = 100
--local damageFunc = workspace.damageFunc
manualguardend = false
player = nil
RSH, LSH = nil, nil
RW, LW = Instance.new("Motor"), Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
TorsoBlue = TorsoColor.Color.b
NewCol = Color3.new(TorsoRed, 0.2, 0.2)
NewCol2 = Color3.new(TorsoRed, TorsoGreen, TorsoBlue)
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
if Player:findFirstChild("Color2") ~= nil then
  NewCol2 = Player.Color2.Value
end
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
kz = Instance.new("BoolValue")
kz.Name = "Absolute"
kz.Parent = mdec
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.2
kz = Instance.new("BoolValue")
kz.Name = "Absolute"
kz.Parent = mdec2
local mdec3 = Instance.new("NumberValue", Decrease)
mdec3.Name = "DecreaseMvmt"
mdec3.Value = 0.1
kz = Instance.new("BoolValue")
kz.Name = "Absolute"
kz.Parent = mdec3
local mdec4 = Instance.new("NumberValue", Decrease)
mdec4.Name = "DecreaseDef"
mdec4.Value = -0.2
bustTarget = nil
local nr = NumberRange.new
local ns = NumberSequence.new
local cs = ColorSequence.new
nsk = NumberSequenceKeypoint.new
local animate = Character:findFirstChild("Animate")
local canjump = true
function removeControl()
  canjump = false
end
function resumeControl()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
function swait(num)
  local stime = tick()
  if num == 0 or num == nil then
    game:GetService("RunService").Heartbeat:wait() --Player.PlayerGui.Pacemaker.Heartbeat.Event:wait()
  else
    for i = 0, num do
      game:GetService("RunService").Heartbeat:wait() --Player.PlayerGui.Pacemaker.Heartbeat.Event:wait()
    end
  end
  return tick() - stime
end
if Character:findFirstChild("Tortoise Shell", true) ~= nil then
  Character:findFirstChild("Tortoise Shell", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 125
Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
TimeLocked = Instance.new("BoolValue")
TimeLocked.Name = "TimeLocked"
TimeLocked.Parent = Stats
TimeLocked.Value = false
tlock = false
TimeLocking = Instance.new("BoolValue")
TimeLocking.Name = "TimeLocking"
TimeLocking.Parent = Stats
TimeLocking.Value = false
LockTime = Instance.new("NumberValue")
LockTime.Name = "Timer"
LockTime.Parent = TimeLocked
LockTime.Value = 0
Unstable = Instance.new("BoolValue")
Unstable.Name = "Unstable"
Unstable.Parent = Stats
Unstable.Value = false
UnstableTime = Instance.new("NumberValue")
UnstableTime.Name = "Timer"
UnstableTime.Parent = Unstable
UnstableTime.Value = 0
Suppressed = Instance.new("BoolValue")
Suppressed.Name = "Suppressed"
Suppressed.Parent = Stats
Suppressed.Value = false
SuppressedTime = Instance.new("NumberValue")
SuppressedTime.Name = "Timer"
SuppressedTime.Parent = Suppressed
SuppressedTime.Value = 0
KnockbackResistance = Instance.new("NumberValue")
KnockbackResistance.Name = "KnockbackResistance"
KnockbackResistance.Parent = Stats
KnockbackResistance.Value = 0
decreasekbr = 0
UltVal = Instance.new("BoolValue")
UltVal.Name = "Ulting"
UltVal.Parent = Stats
UltVal.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
function NoOutline(Part)
  Part.TopSurface, Part.BottomSurface, Part.LeftSurface, Part.RightSurface, Part.FrontSurface, Part.BackSurface = 10, 10, 10, 10, 10, 10
end
function part(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  if parent ~= workspace then
    fp.Parent = parent
  else
    fp.Parent = NoTarget --workspace.NoTarget
  end
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
function mesh(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
function weld(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
function gui(GuiType, parent, text, backtrans, backcol, pos, size, zindex)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  if zindex then
    gui.ZIndex = zindex
  end
  return gui
end
function imggui(GuiType, parent, backtrans, backcol, pos, size, img, imgcol, imgtrans, zindex)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.Position = pos
  gui.Size = size
  gui.Image = img
  gui.ImageColor3 = imgcol
  gui.ImageTransparency = imgtrans
  gui.ZIndex = zindex
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
fenframe3.Name = "MoveFrame"
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "Press 'F' to equip your weapon.", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("Dark green").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarblock1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.6, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarblock2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol).Color, UDim2.new(-0.6, 0, 0, 0), UDim2.new(0.4, 0, -2, 0))
local fenbarblock3 = gui("TextLabel", fenframe, "Block(" .. blocknum .. ")", 1, Color3.new(0, 0, 0), UDim2.new(-0.6, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 1, Color3.new(0.6078431372549019, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0), 2)
local fenbardef = gui("TextLabel", fenframe2, "Defense", 1, Color3.new(0, 0, 0.6078431372549019), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0), 2)
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 1, Color3.new(0, 0.6078431372549019, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0), 2)
local fenimgdmg = imggui("ImageLabel", fenframe2, 1, Color3.new(), UDim2.new(-0.23, 0, 0.1, 0), UDim2.new(0.2, 0, 0.8, 0), "rbxassetid://628793110", Color3.new(0.6666666666666666, 0, 0), 0.35, 1)
local fenimgdef = imggui("ImageLabel", fenframe2, 1, Color3.new(), UDim2.new(-0.46, 0, 0.1, 0), UDim2.new(0.2, 0, 0.8, 0), "rbxassetid://628793046", Color3.new(0, 0, 0.6666666666666666), 0.35, 1)
local fenimgmove = imggui("ImageLabel", fenframe2, 1, Color3.new(), UDim2.new(1.03, 0, 0.1, 0), UDim2.new(0.2, 0, 0.8, 0), "rbxassetid://628793172", Color3.new(0, 0.6666666666666666, 0), 0.35, 1)
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Tortoise Shell"
local nr = NumberRange.new
local ns = NumberSequence.new
local cs = ColorSequence.new
nsk = NumberSequenceKeypoint.new
local rprt1 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part01", vt())
local rprt2 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part02", vt())
local rprt3 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part03", vt())
local rprt4 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part04", vt())
local rprt5 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part05", vt())
local rprt6 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Right Part06", vt())
local rprt7 = part(3, modelzorz, 0, 0, BrickColor.new("Smoky grey"), "Right Part07", vt())
local rprt8 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Right Part08", vt())
local rprt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Right Part09", vt())
local rprt10 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Right Part10", vt())
local rprt11 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Right Part11", vt())
local rprt12 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part12", vt())
local rprt13 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Right Part13", vt())
local rprt14 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Right Part14", vt())
local rprt15 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part15", vt())
local rprt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part16", vt())
local rprt17 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Right Part17", vt())
local rprt18 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Right Part18", vt())
local rprt19 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part19", vt())
local rprt20 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part20", vt())
local rprt21 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part21", vt())
local lprt1 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part01", vt())
local lprt2 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part02", vt())
local lprt3 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part03", vt())
local lprt4 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part04", vt())
local lprt5 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part05", vt())
local lprt6 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Left Part06", vt())
local lprt7 = part(3, modelzorz, 0, 0, BrickColor.new("Smoky grey"), "Left Part07", vt())
local lprt8 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Left Part08", vt())
local lprt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Left Part09", vt())
local lprt10 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Left Part10", vt())
local lprt11 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Left Part11", vt())
local lprt12 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part12", vt())
local lprt13 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Left Part13", vt())
local lprt14 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Left Part14", vt())
local lprt15 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part15", vt())
local lprt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part16", vt())
local lprt17 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Left Part17", vt())
local lprt18 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Left Part18", vt())
local lprt19 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part19", vt())
local lprt20 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part20", vt())
local lprt21 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part21", vt())
rmsh1 = mesh("SpecialMesh", rprt1, "Head", "nil", vt(0, 0, 0), vt(2, 6, 2))
rmsh2 = mesh("SpecialMesh", rprt2, "Sphere", "nil", vt(0, 0, 0), vt(2, 2, 2))
rmsh3 = mesh("SpecialMesh", rprt3, "Sphere", "nil", vt(0, 0, 0), vt(2, 2, 2))
rmsh4 = mesh("SpecialMesh", rprt4, "Head", "nil", vt(0, 0, 0), vt(2, 2, 2))
rmsh5 = mesh("SpecialMesh", rprt5, "Head", "nil", vt(0, 0, 0), vt(2, 2, 2))
rmsh6 = mesh("CylinderMesh", rprt6, "", "", vt(0, 0, 0), vt(8, 1, 8))
rmsh7 = mesh("CylinderMesh", rprt7, "", "", vt(0, 0, 0), vt(3, 1, 3))
rmsh8 = mesh("CylinderMesh", rprt8, "", "", vt(0, 0, 0), vt(7.5, 2, 7.5))
rmsh9 = mesh("SpecialMesh", rprt9, "FileMesh", "3270017", vt(0, 0, 0), vt(1.4, 1.4, 3))
rmsh10 = mesh("CylinderMesh", rprt10, "", "", vt(0, 0, 0), vt(7, 2, 7))
rmsh11 = mesh("CylinderMesh", rprt11, "", "", vt(0, 0, 0), vt(5, 2.1, 5))
rmsh12 = mesh("SpecialMesh", rprt12, "Sphere", "nil", vt(0, 0, 0), vt(4, 3, 4))
rmsh13 = mesh("SpecialMesh", rprt13, "Wedge", "nil", vt(0, 0, 0), vt(5, 4, 4))
rmsh14 = mesh("BlockMesh", rprt14, "", "", vt(0, 0, 0), vt(5, 8, 1))
rmsh15 = mesh("SpecialMesh", rprt15, "FileMesh", "3270017", vt(0, 0, 0), vt(1.3, 1.3, 2))
rmsh16 = mesh("CylinderMesh", rprt16, "", "", vt(0, 0, 0), vt(4, 1, 4))
rmsh17 = mesh("CylinderMesh", rprt17, "", "", vt(0, 0, 0), vt(3.5, 1, 3.5))
rmsh18 = mesh("CylinderMesh", rprt18, "", "", vt(0, 0, 0), vt(2, 1, 2))
rmsh19 = mesh("BlockMesh", rprt19, "", "", vt(0, 0, 0), vt(0.5, 5, 1))
rmsh20 = mesh("BlockMesh", rprt20, "", "", vt(0, 0, 0), vt(0.5, 8, 1))
rmsh21 = mesh("BlockMesh", rprt21, "", "", vt(0, 0, 0), vt(0.5, 8, 1))
lmsh1 = mesh("SpecialMesh", lprt1, "Head", "nil", vt(0, 0, 0), vt(2, 6, 2))
lmsh2 = mesh("SpecialMesh", lprt2, "Sphere", "nil", vt(0, 0, 0), vt(2, 2, 2))
lmsh3 = mesh("SpecialMesh", lprt3, "Sphere", "nil", vt(0, 0, 0), vt(2, 2, 2))
lmsh4 = mesh("SpecialMesh", lprt4, "Head", "nil", vt(0, 0, 0), vt(2, 2, 2))
lmsh5 = mesh("SpecialMesh", lprt5, "Head", "nil", vt(0, 0, 0), vt(2, 2, 2))
lmsh6 = mesh("CylinderMesh", lprt6, "", "", vt(0, 0, 0), vt(8, 1, 8))
lmsh7 = mesh("CylinderMesh", lprt7, "", "", vt(0, 0, 0), vt(3, 1, 3))
lmsh8 = mesh("CylinderMesh", lprt8, "", "", vt(0, 0, 0), vt(7.5, 2, 7.5))
lmsh9 = mesh("SpecialMesh", lprt9, "FileMesh", "3270017", vt(0, 0, 0), vt(1.4, 1.4, 3))
lmsh10 = mesh("CylinderMesh", lprt10, "", "", vt(0, 0, 0), vt(7, 2, 7))
lmsh11 = mesh("CylinderMesh", lprt11, "", "", vt(0, 0, 0), vt(5, 2.1, 5))
lmsh12 = mesh("SpecialMesh", lprt12, "Sphere", "nil", vt(0, 0, 0), vt(4, 3, 4))
lmsh13 = mesh("SpecialMesh", lprt13, "Wedge", "nil", vt(0, 0, 0), vt(5, 4, 4))
lmsh14 = mesh("BlockMesh", lprt14, "", "", vt(0, 0, 0), vt(5, 8, 1))
lmsh15 = mesh("SpecialMesh", lprt15, "FileMesh", "3270017", vt(0, 0, 0), vt(1.3, 1.3, 2))
lmsh16 = mesh("CylinderMesh", lprt16, "", "", vt(0, 0, 0), vt(4, 1, 4))
lmsh17 = mesh("CylinderMesh", lprt17, "", "", vt(0, 0, 0), vt(3.5, 1, 3.5))
lmsh18 = mesh("CylinderMesh", lprt18, "", "", vt(0, 0, 0), vt(2, 1, 2))
lmsh19 = mesh("BlockMesh", lprt19, "", "", vt(0, 0, 0), vt(0.5, 5, 1))
lmsh20 = mesh("BlockMesh", lprt20, "", "", vt(0, 0, 0), vt(0.5, 8, 1))
lmsh21 = mesh("BlockMesh", lprt21, "", "", vt(0, 0, 0), vt(0.5, 8, 1))
local rwld1 = weld(rprt1, rprt1, RightArm, euler(1.57, 0, 0) * cf(0, 1, 0))
local rwld2 = weld(rprt1, rprt2, rprt1, euler(0, 0, 0) * cf(0, 0.6, 0))
local rwld3 = weld(rprt1, rprt3, rprt1, euler(0, 0, 0) * cf(0, -0.6, 0))
local rwld4 = weld(rprt1, rprt4, rprt2, euler(1.57, 0, 0) * cf(0, 0, 0.2))
local rwld5 = weld(rprt1, rprt5, rprt3, euler(1.57, 0, 0) * cf(0, 0, 0.2))
local rwld6 = weld(rprt1, rprt6, rprt1, euler(-1.57, 0, 0) * cf(0, 0, 0.3))
local rwld7 = weld(rprt1, rprt7, rprt6, euler(0, 0, 0) * cf(0, 0.1, 0))
local rwld8 = weld(rprt1, rprt8, rprt7, euler(0, 0, 0) * cf(0, 0.25, 0))
local rwld9 = weld(rprt1, rprt9, rprt8, euler(1.57, 0, 0) * cf(0, 0.05, 0))
local rwld10 = weld(rprt1, rprt10, rprt8, euler(0, 0, 0) * cf(0, 0.1, 0))
local rwld11 = weld(rprt1, rprt11, rprt10, euler(0, 0, 0) * cf(0, 0, 0))
local rwld12 = weld(rprt1, rprt12, rprt11, euler(0, 0, 0) * cf(0, 0.1, 0))
local rwld13 = weld(rprt1, rprt13, rprt6, cf(0, -0.3, -0.4) * euler(0, -1.57, 0))
local rwld14 = weld(rprt1, rprt14, rprt13, euler(0, 0, 0) * cf(0, -0.8, -0.29))
local rwld15 = weld(rprt1, rprt15, rprt14, euler(1.57, 0, 0) * cf(0, 0, 0.7))
local rwld16 = weld(rprt1, rprt16, rprt14, euler(1.57, 0, 0) * cf(0, 0.6, -0.02))
local rwld17 = weld(rprt1, rprt17, rprt14, euler(1.57, 0, 0) * cf(0, 0.6, -0.03))
local rwld18 = weld(rprt1, rprt18, rprt14, euler(1.57, 0, 0) * cf(0, 0.6, -0.04))
local rwld19 = weld(rprt1, rprt19, rprt14, euler(0, 0, 0) * cf(0, -0.29, -0.02))
local rwld20 = weld(rprt1, rprt20, rprt14, euler(0, 0, 0) * cf(0.3, 0.01, -0.02))
local rwld21 = weld(rprt1, rprt21, rprt14, euler(0, 0, 0) * cf(-0.3, 0.01, -0.02))
local lwld1 = weld(rprt1, lprt1, LeftArm, euler(1.57, 3.14, 0) * cf(0, 1, 0))
local lwld2 = weld(rprt1, lprt2, lprt1, euler(0, 0, 0) * cf(0, 0.6, 0))
local lwld3 = weld(rprt1, lprt3, lprt1, euler(0, 0, 0) * cf(0, -0.6, 0))
local lwld4 = weld(rprt1, lprt4, lprt2, euler(1.57, 0, 0) * cf(0, 0, 0.2))
local lwld5 = weld(rprt1, lprt5, lprt3, euler(1.57, 0, 0) * cf(0, 0, 0.2))
local lwld6 = weld(rprt1, lprt6, lprt1, euler(-1.57, 0, 0) * cf(0, 0, 0.3))
local lwld7 = weld(rprt1, lprt7, lprt6, euler(0, 0, 0) * cf(0, 0.1, 0))
local lwld8 = weld(rprt1, lprt8, lprt7, euler(0, 0, 0) * cf(0, 0.25, 0))
local lwld9 = weld(rprt1, lprt9, lprt8, euler(1.57, 0, 0) * cf(0, 0.05, 0))
local lwld10 = weld(rprt1, lprt10, lprt8, euler(0, 0, 0) * cf(0, 0.1, 0))
local lwld11 = weld(rprt1, lprt11, lprt10, euler(0, 0, 0) * cf(0, 0, 0))
local lwld12 = weld(rprt1, lprt12, lprt11, euler(0, 0, 0) * cf(0, 0.1, 0))
local lwld13 = weld(rprt1, lprt13, lprt6, cf(0, -0.3, -0.4) * euler(0, -1.57, 0))
local lwld14 = weld(rprt1, lprt14, lprt13, euler(0, 0, 0) * cf(0, -0.8, -0.29))
local lwld15 = weld(rprt1, lprt15, lprt14, euler(1.57, 0, 0) * cf(0, 0, 0.7))
local lwld16 = weld(rprt1, lprt16, lprt14, euler(1.57, 0, 0) * cf(0, 0.6, -0.02))
local lwld17 = weld(rprt1, lprt17, lprt14, euler(1.57, 0, 0) * cf(0, 0.6, -0.03))
local lwld18 = weld(rprt1, lprt18, lprt14, euler(1.57, 0, 0) * cf(0, 0.6, -0.04))
local lwld19 = weld(rprt1, lprt19, lprt14, euler(0, 0, 0) * cf(0, -0.29, -0.02))
local lwld20 = weld(rprt1, lprt20, lprt14, euler(0, 0, 0) * cf(0.3, 0.01, -0.02))
local lwld21 = weld(rprt1, lprt21, lprt14, euler(0, 0, 0) * cf(-0.3, 0.01, -0.02))
num = 0
for i = 1, 3 do
  local rprts = part(3, modelzorz, 0.5, 0, BrickColor.new("Dark stone grey"), "Right PartS", vt())
  rmshs = mesh("SpecialMesh", rprts, "Wedge", "nil", vt(0, 0, 0), vt(2, 1.5, 2.5))
  local rwlds = weld(rprt1, rprts, rprt10, euler(1.4, 0, 0) * cf(0, 0.25, 0.7) * euler(0, num, 0))
  num = num + 2.093
end
num = -0.9
for i = 1, 2 do
  local rprte1 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Right PartE1", vt())
  local rprte2 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Right PartE2", vt())
  local rprte3 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right PartE3", vt())
  local rprte4 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right PartE4", vt())
  rmshe1 = mesh("SpecialMesh", rprte1, "Wedge", "nil", vt(0, 0, 0), vt(3, 4, 4))
  rmshe2 = mesh("BlockMesh", rprte2, "", "", vt(0, 0, 0), vt(3, 8, 1))
  rmshe3 = mesh("BlockMesh", rprte3, "", "", vt(0, 0, 0), vt(0.25, 9.99, 1))
  rmshe4 = mesh("BlockMesh", rprte4, "", "", vt(0, 0, 0), vt(0.25, 9.99, 1))
  local rwlde1 = weld(rprt1, rprte1, rprt6, cf(0, -0.3, -0.5) * euler(0, -1.57 - num, 0))
  local rwlde2 = weld(rprt1, rprte2, rprte1, euler(0, 0, 0) * cf(0, -0.8, -0.29))
  local rwlde3 = weld(rprt1, rprte3, rprte2, euler(0, 0, 0) * cf(0.125, 0.2, -0.02))
  local rwlde4 = weld(rprt1, rprte4, rprte2, euler(0, 0, 0) * cf(-0.125, 0.2, -0.02))
  num = num + 1.8
end
num = 0
for i = 1, 3 do
  local lprts = part(3, modelzorz, 0.5, 0, BrickColor.new("Dark stone grey"), "Left PartS", vt())
  local lmshs = mesh("SpecialMesh", lprts, "Wedge", "nil", vt(0, 0, 0), vt(2, 1.5, 2.5))
  local lwlds = weld(rprt1, lprts, lprt10, euler(1.4, 0, 0) * cf(0, 0.25, 0.7) * euler(0, num, 0))
  num = num + 2.093
end
num = -0.9
for i = 1, 2 do
  local lprte1 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Left PartE1", vt())
  local lprte2 = part(3, modelzorz, 0.3, 0, BrickColor.new("Dark stone grey"), "Left PartE2", vt())
  local lprte3 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left PartE3", vt())
  local lprte4 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left PartE4", vt())
  local lmshe1 = mesh("SpecialMesh", lprte1, "Wedge", "nil", vt(0, 0, 0), vt(3, 4, 4))
  local lmshe2 = mesh("BlockMesh", lprte2, "", "", vt(0, 0, 0), vt(3, 8, 1))
  local lmshe3 = mesh("BlockMesh", lprte3, "", "", vt(0, 0, 0), vt(0.25, 9.99, 1))
  local lmshe4 = mesh("BlockMesh", lprte4, "", "", vt(0, 0, 0), vt(0.25, 9.99, 1))
  local lwlde1 = weld(rprt1, lprte1, lprt6, cf(0, -0.3, -0.5) * euler(0, -1.57 - num, 0))
  local lwlde2 = weld(rprt1, lprte2, lprte1, euler(0, 0, 0) * cf(0, -0.8, -0.29))
  local lwlde3 = weld(rprt1, lprte3, lprte2, euler(0, 0, 0) * cf(0.125, 0.2, -0.02))
  local lwlde4 = weld(rprt1, lprte4, lprte2, euler(0, 0, 0) * cf(-0.125, 0.2, -0.02))
  num = num + 1.8
end
local shield = part(0.2, nil, 0, 1, BrickColor.new("Bright green"), "Shield", vt())
shield.Anchored = true
smsh = mesh("SpecialMesh", shield, "FileMesh", "90782182", vt(0, 0, 0), vt(0.7, 1, 0.7))
smsh.TextureId = "http://www.roblox.com/asset/?id=544081819"
smsh.VertexColor = Vector3.new(NewCol.r + 0.3, NewCol.g + 0.3, NewCol.b + 0.3)
local shield1 = part(3, nil, 0, 0.25, BrickColor.new("Bright green"), "Shield", vt())
smsh = mesh("SpecialMesh", shield1, "FileMesh", "90782182", vt(0, 0, 0), vt(0.65, 0.65, 0.65))
smsh.TextureId = "http://www.roblox.com/asset/?id=544081819"
smsh.VertexColor = Vector3.new(NewCol.r + 0.3, NewCol.g + 0.3, NewCol.b + 0.3)
swld = weld(shield1, shield1, Torso, euler(0, 0, 0) * cf(0, -1.8, 0))
local shield2 = part(3, nil, 0, 0.25, BrickColor.new("Bright green"), "Shield", vt())
smsh = mesh("SpecialMesh", shield2, "FileMesh", "90782182", vt(0, 0, 0), vt(0.65, 0.65, 0.65))
smsh.TextureId = "http://www.roblox.com/asset/?id=544081819"
smsh.VertexColor = Vector3.new(NewCol.r + 0.3, NewCol.g + 0.3, NewCol.b + 0.3)
swld = weld(shield2, shield2, Torso, euler(3.14, 0, 0) * cf(0, 1.8, 0))
local ball = part(3, nil, 0, 1, BrickColor.new("White"), "Ball", vt(6, 6, 6))
ball.CanCollide = true
ball.Shape = "Ball"
ballw = weld(ball, ball, Torso, euler(0, 0, 0) * cf(0, 0, 0))
for _, c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _, c in pairs(rprt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
function hitboxweld()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = lprt7
end
Tool = Instance.new("HopperBin")
Tool.Parent = Backpack
Tool.Name = "Omega"
Bin = Tool
if Bin.Name == "Omega" then
  Bin.Name = "Tortoise Shell"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
function so(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a, b, t)
  local qa = {
    QuaternionFromCFrame(a)
  }
  local qb = {
    QuaternionFromCFrame(b)
  }
  local ax, ay, az = a.x, a.y, a.z
  local bx, by, bz = b.x, b.y, b.z
  local _t = 1 - t
  return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
  local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
  local trace = m00 + m11 + m22
  if trace > 0 then
    local s = math.sqrt(1 + trace)
    local recip = 0.5 / s
    return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
  else
    local i = 0
    if m00 < m11 then
      i = 1
    end
    if m22 > (i == 0 and m00 or m11) then
      i = 2
    end
    if i == 0 then
      local s = math.sqrt(m00 - m11 - m22 + 1)
      local recip = 0.5 / s
      return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
    elseif i == 1 then
      local s = math.sqrt(m11 - m22 - m00 + 1)
      local recip = 0.5 / s
      return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
    elseif i == 2 then
      local s = math.sqrt(m22 - m00 - m11 + 1)
      local recip = 0.5 / s
      return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
    end
  end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
  local xs, ys, zs = x + x, y + y, z + z
  local wx, wy, wz = w * xs, w * ys, w * zs
  local xx = x * xs
  local xy = x * ys
  local xz = x * zs
  local yy = y * ys
  local yz = y * zs
  local zz = z * zs
  return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
  local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
  local startInterp, finishInterp
  if cosTheta >= 1.0E-4 then
    if 1 - cosTheta > 1.0E-4 then
      local theta = math.acos(cosTheta)
      local invSinTheta = 1 / math.sin(theta)
      startInterp = math.sin((1 - t) * theta) * invSinTheta
      finishInterp = math.sin(t * theta) * invSinTheta
    else
      startInterp = 1 - t
      finishInterp = t
    end
  elseif 1 + cosTheta > 1.0E-4 then
    local theta = math.acos(-cosTheta)
    local invSinTheta = 1 / math.sin(theta)
    startInterp = math.sin((t - 1) * theta) * invSinTheta
    finishInterp = math.sin(t * theta) * invSinTheta
  else
    startInterp = t - 1
    finishInterp = t
  end
  return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function hideanim()
  equipped = false
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, RHC0, 0.4)
    LH.C0 = clerp(LH.C0, LHC0, 0.4)
  end
  mdec2.Parent = nil
  mdec.Parent = Decrease
end
mdec.Parent = Decrease
function equipanim()
  equipped = true
  mdec.Parent = nil
  mdec2.Parent = Decrease
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(2, 0, -1.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.3, 0, 1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
  end
end
tlock = false
function TimeLock()
  so(535381634, RootPart, 0.5, math.random(145, 155) / 100 - TimeLocked.Timer.Value * 0.15)
  local b, f, f2
  if RootPart:FindFirstChild("TimeLockGui") then
    b = RootPart.TimeLockGui
    f = b.ImageLabel
    f2 = b.ImageLabel2
    f2.ImageTransparency = 0.25
    f2.Size = UDim2.new(1, 0, 1, 0)
    f2.Position = UDim2.new(0, 0, 0, 0)
  else
    b = Instance.new("BillboardGui")
    b.Name = "TimeLockGui"
    b.Size = UDim2.new(4, 0, 4, 0)
    b.SizeOffset = Vector2.new(0, 1.2)
    b.Parent = RootPart
    f = Instance.new("ImageLabel")
    f.BackgroundTransparency = 1
    f.Size = UDim2.new(1, 0, 1, 0)
    f.ImageColor3 = Color3.new(0, 1, 1)
    f.Image = "rbxassetid://535799774"
    f.Parent = b
    f.ImageTransparency = 1
    f2 = Instance.new("ImageLabel")
    f2.Name = "ImageLabel2"
    f2.BackgroundTransparency = 1
    f2.Size = UDim2.new(1, 0, 1, 0)
    f2.ImageColor3 = Color3.new(0, 1, 1)
    f2.Image = "rbxassetid://535799774"
    f2.Parent = b
    f2.ImageTransparency = 0.25
  end
  local partif2z = it("ParticleEmitter")
  partif2z.Color = cs(Color3.new(0, 1, 1), Color3.new(0.4, 1, 1))
  partif2z.LightEmission = 0.5
  partif2z.Texture = "rbxasset://textures/particles/sparkles_main.dds"
  sizeseq = ns({
    nsk(0, 8),
    nsk(1, 10)
  })
  transseq = ns({
    nsk(0, 0.98),
    nsk(1, 1)
  })
  partif2z.Transparency = transseq
  partif2z.Size = sizeseq
  partif2z.ZOffset = 0
  partif2z.LockedToPart = true
  partif2z.EmissionDirection = "Front"
  partif2z.Lifetime = nr(0.9, 1.2)
  partif2z.Rate = 30
  partif2z.Rotation = nr(-180, 180)
  partif2z.RotSpeed = nr(-80, 80)
  partif2z.Speed = nr(3, 6)
  partif2z.VelocitySpread = 330
  partif2z.Parent = RootPart
  partif2z.Enabled = true
  coroutine.resume(coroutine.create(function(p, c, d)
    swait()
    c:Emit(10)
    repeat
      d.Size = d.Size + UDim2.new(0.1, 0, 0.1, 0)
      d.Position = d.Position - UDim2.new(0.05, 0, 0.05, 0)
      d.ImageTransparency = d.ImageTransparency + wait() * 6
      p.ImageTransparency = p.ImageTransparency - wait() * 7.5
      if 0 > p.ImageTransparency then
        p.ImageTransparency = 0
      end
    until p.ImageTransparency == 0 or TimeLocked.Value == false
  end), f, partif2z, f2)
  repeat
    RootPart.Anchored = true
    swait()
  until TimeLocked.Value == false
  coroutine.resume(coroutine.create(function(p, c, d)
    d.Size = d.Size + UDim2.new(0.1, 0, 0.1, 0)
    d.Position = d.Position - UDim2.new(0.05, 0, 0.05, 0)
    d.ImageTransparency = d.ImageTransparency + wait() * 6
    game:GetService("Debris"):AddItem(c, 5)
    c.Enabled = false
    repeat
      p.ImageTransparency = p.ImageTransparency + wait() * 9
      if p.ImageTransparency > 1 then
        p.ImageTransparency = 1
      end
    until p.ImageTransparency == 1 or TimeLocked.Value == true
    if TimeLocked.Value == false then
      p.Parent:Destroy()
    end
  end), f, partif2z, f2)
  RootPart.Anchored = false
  tlock = false
end
unst = false
function UnstableAnim()
  attack = true
  unst = true
  local rndc = 1
  local rnda = math.random(-1, 0)
  showDamage(Character, "Off balance!", "Interrupt")
  --workspace.damguiFunc:FireServer(Character, "Off balance!", "Interrupt")
  removeControl()
  repeat
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0.3 * rndc, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, cf(0, -0.3 - math.cos(time() * 14) * 0.04, 0.4 - math.cos(time() * 14) * 0.02) * euler(math.rad(90 + 25 * rndc), math.rad(180), math.rad(0)), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.4 - math.cos(time() * 14) * 0.5 - rndc * 0.2, math.cos(time() * 14) * 0.2, math.sin(time() * 14) * 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.4 + math.cos(time() * 14) * 0.5 + rndc * 0.2, math.cos(time() * 14) * 0.2, math.sin(time() * 14) * 0.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8 + math.cos(time() * 14) * 0.3, 0 - math.sin(time() * 14) * 0.3) * euler(0, 1.57, 0) * euler(0, -0.1, -math.rad(9 * rndc) - math.cos(time() * 14) * 1), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8 - math.cos(time() * 14) * 0.3, 0 + math.sin(time() * 14) * 0.3) * euler(0, -1.57, 0) * euler(0, 0.1, math.rad(9 * rndc) - math.cos(time() * 14) * 1), 0.3)
  until Stun.Value >= StunT.Value or Stunned.Value == true or 0 >= UnstableTime.Value or Unstable.Value == false or Stagger.Value == true or Suppressed.Value == true
  unst = false
  attack = false
  resumeControl()
end
suppress = false
function SuppressedAnim()
  showDamage(Character, "Suppressed!", "Interrupt")
  --workspace.damguiFunc:FireServer(Character, "Suppressed!", "Interrupt")
  removeControl()
  repeat
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Suppressed:FindFirstChild("AnimOverride") == nil then
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, cf(0, 0, 0) * euler(math.rad(90), math.rad(180), math.rad(0)), 0.2)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
    else
      Neck.C0 = clerp(Neck.C0, Suppressed.AnimOverride.Neck.Value, 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, Suppressed.AnimOverride.RootJoint.Value, 0.2)
      RW.C0 = clerp(RW.C0, Suppressed.AnimOverride.RightShoulderC0.Value, 0.3)
      RW.C1 = clerp(LW.C1, Suppressed.AnimOverride.RightShoulderC1.Value, 0.3)
      LW.C0 = clerp(LW.C0, Suppressed.AnimOverride.LeftShoulderC0.Value, 0.3)
      LW.C1 = clerp(LW.C1, Suppressed.AnimOverride.LeftShoulderC1.Value, 0.3)
      RH.C0 = clerp(RH.C0, Suppressed.AnimOverride.RightHip.Value, 0.3)
      LH.C0 = clerp(LH.C0, Suppressed.AnimOverride.LeftHip.Value, 0.3)
    end
  until 0 >= SuppressedTime.Value or Suppressed.Value == false
  suppress = false
  resumeControl()
end
function StaggerAnim()
  attack = true
  removeControl()
  showDamage(Character, "Staggered!", "Interrupt")
  --workspace.damguiFunc:FireServer(Character, "Staggered!", "Interrupt")
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
    if Stun.Value >= StunT.Value or Stunned.Value == true or Suppressed.Value == true then
      break
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
    if Stun.Value >= StunT.Value or Stunned.Value == true or Suppressed.Value == true then
      break
    end
  end
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
    if Stun.Value >= StunT.Value or Stunned.Value == true or Suppressed.Value == true then
      break
    end
  end
  for i = 1, 50 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Stun.Value >= StunT.Value or Stunned.Value == true or Suppressed.Value == true then
      break
    end
  end
  resumeControl()
  combo = 0
  attack = false
end
function StunAnim()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned!", "Interrupt")
  --workspace.damguiFunc:FireServer(Character, "Stunned!", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 100
  for i = 0, 1, 0.3 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Suppressed.Value == true then
      break
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Suppressed.Value == true then
      break
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Suppressed.Value == true then
      break
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(2000, 0, 2000)
  gairost.P = 2000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Suppressed.Value == true then
      break
    end
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Suppressed.Value == true then
      break
    end
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false
    end
    if Suppressed.Value == true then
      break
    end
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  combo = 0
  Stunned.Value = false
  attack = false
  Stun.Value = 0
end
function attackone()
  attack = true
  for i = 0, 1, 0.2 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, 0.5) * euler(0.8, 0, 0.5), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.6, 0, 1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1.1, -1, 0) * euler(0, 0.87, -0.1), 0.2)
    LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -2.27, 0.4), 0.2)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  so("200632136", lprt7, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1.5, 2, 1.5)
  hitboxCF = lprt7.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.4 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    hitboxCF = lprt7.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 2, 0, 10, 12, "Normal", RootPart, 0.5, 1, 12, nil, true)
    lwld8.C0 = lwld8.C0 * euler(0, 0.4, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 0.7) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.7), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.6, 0, -0.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.7, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0) * euler(0, 0.7, 0.1), 0.4)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    hitboxCF = lprt7.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 2, 0, 10, 12, "Normal", RootPart, 0.5, 1, 12, nil, true)
    lwld8.C0 = lwld8.C0 * euler(0, 0.4, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 1.2) * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.2), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.6, 0, 0.6), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, 0.3) * euler(0, -0.5, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.2, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.6, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.4)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
function attacktwo()
  attack = true
  for i = 0, 1, 0.12 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 1) * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.4, 0, -1), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.6, 0, -1) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  so("200632211", rprt7, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1.5, 2, 1.5)
  hitboxCF = rprt7.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    hitboxCF = rprt7.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 2.5, 0, 10, 12, "Normal", RootPart, 0.5, 1, 12, nil, true)
    rwld8.C0 = rwld8.C0 * euler(0, 0.4, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -1.57) * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.57), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.8, 0, 1.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.4, 0, -0.1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
function attackthree()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0.4, 0, 0.6), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.6, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.6, 0), 0.4)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  so("200632136", lprt7, 1, 0.8)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1.5, 2, 1.5)
  hitboxCF = lprt7.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.35 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    hitboxCF = lprt7.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 2.5, 0, 10, 12, "Normal", RootPart, 0.5, 1, 12, nil, true)
    lwld8.C0 = lwld8.C0 * euler(0, 0.4, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 0, -1), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 3.14, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.5, -1, -0.2) * euler(0, 1.57, 0) * euler(-0.4, 1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.5, -1, 0.2) * euler(0, -1.57, 0) * euler(0.2, 1.57, 0), 0.2)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    hitboxCF = lprt7.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 2, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 1, math.random(10, 15), nil, true)
    lwld8.C0 = lwld8.C0 * euler(0, 0.4, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 0, -1), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 3.14, 1.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.5, -1, -0.2) * euler(0, 1.57, 0) * euler(-0.4, 1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.5, -1, 0.2) * euler(0, -1.57, 0) * euler(0.2, 1.57, 0), 0.2)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
function attackfour()
  attack = true
  for i = 0, 1, 0.1 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -0.1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  so("200632370", rprt7, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1.5, 2, 1.5)
  hitboxCF = rprt7.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.03 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    hitboxCF = rprt7.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 2.7, 0, 7, 4, "Normal", RootPart, 0.5, 1, 6, nil, true)
    rwld8.C0 = rwld8.C0 * euler(0, 0.5, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.57), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(0, 1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      break
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
local BlockSc = Instance.new("Script") --script:WaitForChild("OmegaBlockScript"):clone()
BlockSc.Disabled = false
BlockSc.Parent = Character
BlockSc.Name = "OmegaBlockScript"
Character:WaitForChild("OmegaBlockScript")
wait()
BlockObj = Instance.new("BoolValue", BlockSc) --BlockSc:WaitForChild("Active")
BlockObj.Name = "Active"
BlockObj.Value = true
BlockVal = Instance.new("NumberValue", BlockSc) --BlockSc:WaitForChild("ShieldHealth")
BlockVal.Name = "ShieldHealth"
BlockVal.Value = 10
function Guard()
  if Suppressed.Value == true or Stun.Value >= StunT.Value or Stunned.Value == true or Unstable.Value == true then
    return
  end
  attack = true
  manualguardend = false
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 0.1
  local dec2 = Instance.new("NumberValue", Decrease)
  dec2.Name = "DecreaseKBR"
  dec2.Value = 0
  kz = Instance.new("BoolValue")
  kz.Name = "Absolute"
  kz.Parent = dec
  shield.Transparency = 1
  shield.Parent = modelzorz
  shield.Anchored = false
  local swld = weld(shield, shield, Torso, cf(0, 0, 0))
  guard = true
  removeControl()
  for i = 1, 6 do
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    shield.Mesh.VertexColor = Vector3.new(NewCol.r * 1.1 + 0.25, NewCol.g * 1.1 + 0.25, NewCol.b * 1.1 + 0.25) * (BlockVal.Value / 40)
    shield.Mesh.Scale = Vector3.new(0.7, 1, 0.7) + Vector3.new(0.35, 0.35, 0.35) * (BlockVal.Value / 40)
    shield.Transparency = (0.9 - BlockVal.Value / 100) / 6 * i
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0, -1) * euler(3, 0, 0) * euler(0, -1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 0, -1) * euler(2.9, 0, 0) * euler(0, 1.57, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1.1, -1, 0) * euler(0, 1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0), 0.2)
    if i == 4 then
      BlockObj.Value = true
    end
    if Suppressed.Value == true or Stun.Value >= StunT.Value or Stunned.Value == true or Unstable.Value == true then
      break
    end
  end
  if Suppressed.Value == true or Stun.Value >= StunT.Value or Stunned.Value == true or Unstable.Value == true then
    resumeControl()
    dec2:Destroy()
    BlockObj.Value = false
    shield.Parent = nil
    swld:Destroy()
    guard = false
    dec.Parent = nil
    attack = false
    return
  end
  if Unstable.Value == true then
    Unstable.Value = false
    Unstable.Timer.Value = 0
  end
  if Stagger.Value == true then
    Stagger.Value = false
  end
  repeat
    swait()
    if TimeLocked.Value == true then
      repeat
        game:GetService("RunService").Heartbeat:wait()
      until TimeLocked.Value == false or Suppressed.Value == true
    end
    if Stun.Value >= StunT.Value or Stunned.Value == true then
      break
    end
    if Unstable.Value == true then
      Unstable.Value = false
      Unstable.Timer.Value = 0
    end
    if Stagger.Value == true then
      Stagger.Value = false
    end
    shield.Mesh.VertexColor = Vector3.new(NewCol.r * 1.1 + 0.25, NewCol.g * 1.1 + 0.25, NewCol.b * 1.1 + 0.25) * (BlockVal.Value / 40)
    shield.Mesh.Scale = Vector3.new(0.7, 1, 0.7) + Vector3.new(0.35, 0.35, 0.35) * (BlockVal.Value / 40)
    shield.Transparency = 0.9 - BlockVal.Value / 100
  until 0 >= BlockVal.Value or guard == false
  resumeControl()
  dec2:Destroy()
  BlockObj.Value = false
  shield.Parent = nil
  swld:Destroy()
  guard = false
  dec.Parent = nil
  attack = false
end
function do1()
  if attack == true then
    return
  end
  if attack == true or equipped == false or Stunned.Value == true or Stagger.Value == true or Unstable.Value == true or Suppressed.Value == true then
    return
  end
  if cooldowns[1] >= cooldownmax and mana.Value >= 20 then
    mana.Value = mana.Value - 20
    attack = true
    so("200632449", Torso, 1, 1)
    MagicCircle(BrickColor.new(NewCol), Torso.CFrame, 50, 50, 50, 1, 1, 1, 0.05)
    shieldroll = true
    shield1.Parent = modelzorz
    shield2.Parent = modelzorz
    ball.Parent = workspace
    Humanoid.PlatformStand = true
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    msh = mesh("BlockMesh", ref, "", "", vt(0, 0, 0), vt(10, 10, 10))
    angl = it("BodyVelocity")
    angl.maxForce = Vector3.new(46500, 265, 46500)
    angl.P = angl.P * 4
    angl.Parent = ball
    angl.velocity = ref.CFrame.lookVector * 80
    mananum = 0
    velnum = 0
    manacost = 1
    manacostnum = 0
    workspace.CurrentCamera.CameraSubject = ball
    local cz, xps, cl, clz, start, csz = 0, 10, 0.04, 0, RootPart.Position, 0.25
    local dist, mag, vp, t = 0, 0, nil, nil
    bustTarget = nil
    local cld = Instance.new("NumberValue", Decrease)
    cld.Name = "DecreaseDef"
    cld.Value = -0.2
    local cld2 = Instance.new("NumberValue", Decrease)
    cld2.Name = "DecreaseKBR"
    cld2.Value = 1
    while shieldroll == true and dist <= 45 do
      swait()
      cld.Parent = Decrease
      cld2.Parent = Decrease
      dist = dist + (start - RootPart.Position).magnitude
      start = RootPart.Position
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true then
        break
      end
      if Unstable.Value == true then
        Unstable.Value = false
        Unstable.Timer.Value = 0
      end
      if Stagger.Value == true then
        Stagger.Value = false
      end
      if csz >= 1 then
        clz = clz + cl
      else
        csz = csz + 0.075
        if csz > 1 then
          csz = 1
        end
      end
      Humanoid.PlatformStand = true
      hitboxCF = ball.CFrame
      hitbox.CFrame = hitboxCF
      cz = workspace.CurrentCamera.CoordinateFrame.lookVector
      if player:FindFirstChild("ShiftLockEnabled") then
        ref.CFrame = cf(RootPart.Position, RootPart.Position + Vector3.new(cz.x, 0, cz.z).unit * 50)
      else
        ref.CFrame = cf(RootPart.Position, MMouse.hit.p)
      end
      angl.velocity = ref.CFrame.lookVector * ((11.25 + xps / (1 + clz)) * csz)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 0, -1) * euler(3, 0, 0) * euler(0, -1.57, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0, -1) * euler(2.9, 0, 0) * euler(0, 1.57, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.4, -0.4) * euler(0, 1.57, 0) * euler(-0.1, 0, -0.5), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1, -0.4, -0.4) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.5), 0.2)
      for _, v in pairs(workspace:children()) do
        if v.className == "Model" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") then
          t = v.HumanoidRootPart
          vp = game.Players:GetPlayerFromCharacter(v)
          if vp == nil then
            if v:FindFirstChild("Alignment") then
              if v.Alignment.Value ~= Player.TeamColor or Player.Neutral == true then
                mag = (t.Position - ball.Position).magnitude
                if mag <= 7 then
                  bustTarget = v
                end
              end
            else
              mag = (t.Position - ball.Position).magnitude
              if mag <= 7 then
                bustTarget = v
              end
            end
          elseif vp.TeamColor ~= Player.TeamColor or Player.Neutral == true and vp.Neutral == true and vp ~= Player then
            mag = (t.Position - ball.Position).magnitude
            if mag <= 7 then
              bustTarget = v
            end
          end
        end
      end
      if bustTarget ~= nil then
        break
      end
    end
    cld:Destroy()
    cld2:Destroy()
    RootPart.CFrame = CFrame.new(RootPart.Position, RootPart.Position + Vector3.new(angl.velocity.x, 0, angl.velocity.z))
    if not bustTarget or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true then
    else
      Damagefunc(bustTarget.Torso, 0, 15, 0, 15, RootPart, 0, "Normal", 20, false, false, false, "Movement", 0.25, 120)
    end
    if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true then
    else
      local vvel = Instance.new("BodyVelocity")
      vvel.P = 400
      vvel.maxForce = Vector3.new(21500, 16500, 21500)
      vvel.velocity = Vector3.new(0, 20, 0)
      vvel.Parent = RootPart
      game:GetService("Debris"):AddItem(vvel, 0.25)
      if bustTarget then
        vvel.velocity = vvel.velocity - (bustTarget.HumanoidRootPart.Position - RootPart.Position).unit * 4
      end
--[[
      s = script.Root:clone()
      s.Parent = Decrease.Parent.Rooted
      s.Disabled = false
]]
    end
    bustTarget = nil
    workspace.CurrentCamera.CameraSubject = Humanoid
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
    MagicCircle(BrickColor.new(NewCol), Torso.CFrame, 50, 50, 50, 1, 1, 1, 0.05)
    Stagger.Value = false
    StaggerHit.Value = false
    angl.Parent = nil
    ref.Parent = nil
    Humanoid.PlatformStand = false
    Humanoid.Jump = true
    Humanoid:ChangeState("GettingUp")
    shield1.Parent = nil
    shield2.Parent = nil
    ball.Parent = nil
    attack = false
    cooldowns[1] = 0
  end
  shieldroll = false
end
function do2()
  if attack == true then
    return
  end
  if attack == true or equipped == false or Stunned.Value == true or Stagger.Value == true or Unstable.Value == true or Suppressed.Value == true then
    return
  end
  if cooldowns[2] >= cooldownmax then
    attack = true
    stance = true
    removeControl()
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 100
    for i = 0, 1, 0.25 do
      swait()
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(2, 0, -1.2), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.3, 0, 1), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1.1, -1, 0) * euler(0, 1.57, -0.1), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0.4), 0.2)
      if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
        break
      end
    end
    stancetime = 0
    while stance == true do
      swait()
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      stancetime = stancetime + 1
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.8) * euler(0.1, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.8), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1, 0, -0.5), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, 0.2) * euler(1.8, 0, 0.3), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, 0) * euler(0, 1.77, -0.4), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1.1, -1, 0) * euler(0, -1.07, 0.1), 0.2)
      if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
        break
      end
    end
    if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
      dec:Destroy()
      attack = false
      stance = false
      return
    end
    if sattack ~= "None" then
      cooldowns[2] = 0
    end
    if sattack == "None" then
    elseif sattack == "AirGrab" then
      attack = true
      stance = false
      grabbing = true
      local par, loc
      local etime = time()
      repeat
        swait()
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p - Vector3.new(0, 3.3, 0))
        if 2 < time() - etime then
          break
        end
      until par ~= nil or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health
      for i = 1, 6 do
        swait()
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.1, -0.4) * CFrame.fromEulerAnglesXYZ(math.rad(10), math.rad(-10), math.rad(-30)), 0.35)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(20)), 0.35)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(-0.66, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(20), math.rad(75)), 0.35)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(20), math.rad(-90)), 0.35)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.25, 0.5, -0.05) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(5)), 0.35)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0.3, 0.05) * CFrame.Angles(math.rad(0), math.rad(35), math.rad(10)), 0.35)
        if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
          break
        end
      end
      if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
        RootPart.Anchored = false
        grabbing = false
        attack = false
        Humanoid.AutoRotate = true
        resumeControl()
        dec:Destroy()
        return
      end
      bustTarget = nil
      Humanoid.AutoRotate = false
      for i = 1, 12 do
        swait()
        local vp, t, loc, par, mag
        if i >= 3 and i <= 10 then
          for _, v in pairs(workspace:children()) do
            if v.className == "Model" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") then
              t = v.HumanoidRootPart
              vp = game.Players:GetPlayerFromCharacter(v)
              if vp == nil then
                if v:FindFirstChild("Alignment") then
                  if v.Alignment.Value ~= Player.TeamColor or Player.Neutral == true then
                    mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -1.45, 0)).p).magnitude
                    if mag <= 6 then
                      par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5.25, 0))
                      if par == nil then
                        print("GOE")
                        bustTarget = v
                      end
                    end
                  end
                else
                  mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -1.45, 0)).p).magnitude
                  if mag <= 6 then
                    par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5.25, 0))
                    if par == nil then
                      print("GOE")
                      bustTarget = v
                    end
                  end
                end
              elseif vp.TeamColor ~= Player.TeamColor or Player.Neutral == true and vp.Neutral == true and vp ~= Player then
                mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -1.45, 0)).p).magnitude
                if mag <= 6 then
                  par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5.25, 0))
                  if par == nil then
                    print("GOE")
                    bustTarget = v
                  end
                end
              end
            end
          end
        end
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, -0.2, -0.15) * CFrame.fromEulerAnglesXYZ(math.rad(-4), math.rad(5), math.rad(65)), 0.45)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-5), math.rad(5), math.rad(-30)), 0.45)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.65, 0.35, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-66), math.rad(115)), 0.45)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.45)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.4, -0.2, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-20), math.rad(70), math.rad(-30)), 0.45)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.45)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, -0.05, -0.05) * CFrame.Angles(math.rad(5), math.rad(0), -math.rad(0)), 0.45)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0.1, 0.25, -0.2) * CFrame.Angles(-math.rad(22), math.rad(45), math.rad(-3)), 0.45)
        if bustTarget or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
          break
        end
      end
      if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
        RootPart.Anchored = false
        grabbing = false
        attack = false
        resumeControl()
        Humanoid.AutoRotate = true
        dec:Destroy()
        return
      end
      if bustTarget then
        local stats = bustTarget:FindFirstChild("Stats")
        if stats and stats:FindFirstChild("Ulting") and stats.Ulting.Value == false and stats:FindFirstChild("Grabbed") == nil then
          local gval = Instance.new("StringValue", stats)
          gval.Name = "Grabbed"
          gval.Value = Player.Name
          stats.Suppressed.Value = true
          workspace.suppFunc:FireServer(stats, true, 10)
          so("200632821", bustTarget.HumanoidRootPart, 1, 1)
          bustTarget.HumanoidRootPart.Anchored = true
          bustTarget.HumanoidRootPart.CFrame = RightArm.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(math.pi / 2, 0, math.pi)
          local vvel = 0.1
          workspace.CurrentCamera.CameraType = "Track"
          for i = 1, 8 do
            swait()
            if TimeLocked.Value == true then
              repeat
                game:GetService("RunService").Heartbeat:wait()
              until TimeLocked.Value == false or Suppressed.Value == true
            end
            bustTarget.HumanoidRootPart.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(0, -2.5, 0)).p:lerp((LeftArm.CFrame * CFrame.new(0, -2.5, 0)).p, i / 12), RootPart.CFrame.p) * CFrame.Angles(0, 0, math.pi / 2 / 8 * i)
            RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-20), math.rad(0), math.rad(0)), 0.35)
            Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(10), math.rad(0), math.rad(0)), 0.35)
            RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-10), math.rad(200)), 0.35)
            RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
            LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(10), -math.rad(200)), 0.35)
            LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
            RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(4), math.rad(0), math.rad(-20)), 0.35)
            LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(4), math.rad(0), math.rad(35)), 0.35)
            if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
              break
            end
          end
          if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            gval:Destroy()
            if vvel and type(vvel) ~= "number" then
              vvel:Destroy()
            end
            RootPart.Anchored = false
            workspace.suppFunc:FireServer(stats, false, 0)
            dec:Destroy()
            bustTarget.HumanoidRootPart.Anchored = false
            grabbing = false
            attack = false
            resumeControl()
            Humanoid.AutoRotate = true
            return
          end
          RootPart.Anchored = true
          local vdir = Vector3.new(RootPart.CFrame.lookVector.x, 0, RootPart.CFrame.lookVector.z).unit
          local locx, locy, par2
          for i = 1, 20 do
            swait()
            if i == 1 or i % 14 == 0 then
              so("541546847", bustTarget.HumanoidRootPart, 1, 1.1)
            end
            if TimeLocked.Value == true then
              repeat
                game:GetService("RunService").Heartbeat:wait()
              until TimeLocked.Value == false or Suppressed.Value == true
            end
            RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 1)
            Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(10), math.rad(0), math.rad(0)), 0.35)
            RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(10), math.rad(90)), 0.35)
            RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
            LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-10), -math.rad(90)), 0.35)
            LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
            RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.75, 0.75, 0) * CFrame.Angles(-math.rad(4), math.rad(0), math.rad(-10)), 0.35)
            LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.75, 0.75, 0) * CFrame.Angles(-math.rad(4), math.rad(0), math.rad(10)), 0.35)
            RootPart.CFrame = RootPart.CFrame * CFrame.Angles(-math.rad(4.2) * i, 0, 0)
            par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + vdir * 5)
            if par == nil then
              par2, locx = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + vdir * vvel)
              RootPart.CFrame = RootPart.CFrame - (RootPart.Position - locx) * 1
            else
              RootPart.CFrame = RootPart.CFrame - vdir * (4.9 - (loc - RootPart.Position).magnitude)
            end
            par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + Vector3.new(0, 1.2 - i * 0.06, 0))
            if par == nil then
              par2, locy = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + Vector3.new(0, 1.2 - i * 0.06, 0))
              RootPart.CFrame = RootPart.CFrame - (RootPart.Position - locy) * 1
            else
              RootPart.CFrame = RootPart.CFrame - Vector3.new(0, 1, 0) * (2 - (loc - RootPart.Position).magnitude)
            end
            vvel = vvel + 0.3 / (1 + i)
            bustTarget.HumanoidRootPart.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(0, -2.5, 0)).p:lerp((LeftArm.CFrame * CFrame.new(0, -2.5, 0)).p, 0.5), Torso.Position) * CFrame.Angles(0, 0, -math.pi / 2)
            if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
              break
            end
          end
          if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            gval:Destroy()
            if vvel and type(vvel) ~= "number" then
              vvel:Destroy()
            end
            RootPart.Anchored = false
            workspace.suppFunc:FireServer(stats, false, 0)
            dec:Destroy()
            bustTarget.HumanoidRootPart.Anchored = false
            grabbing = false
            attack = false
            resumeControl()
            Humanoid.AutoRotate = true
            return
          end
          local k, z = 0, 2
          for i = 21, 41 do
            swait()
            k = i
            z = z ^ 1.09
            if TimeLocked.Value == true then
              repeat
                game:GetService("RunService").Heartbeat:wait()
              until TimeLocked.Value == false or Suppressed.Value == true
            end
            RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, -0.1) * CFrame.fromEulerAnglesXYZ(math.rad(0), -math.rad(10), math.rad(-40)), 0.2)
            Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(20), math.rad(0), math.rad(30)), 0.2)
            RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-20), math.rad(-50), math.rad(100)), 0.2)
            RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.2)
            LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-40), math.rad(40), math.rad(-80)), 0.25)
            LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.2)
            RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(20), math.rad(-40)), 0.2)
            LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(20), math.rad(40)), 0.2)
            RootPart.CFrame = RootPart.CFrame * CFrame.Angles(-math.rad(84) / (1 + (i - 20)), 0, 0)
            par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + vdir * 5)
            if par == nil then
              par2, locx = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + vdir * vvel)
              RootPart.CFrame = RootPart.CFrame - (RootPart.Position - locx) * 1
            else
              RootPart.CFrame = RootPart.CFrame - vdir * (4.9 - (loc - RootPart.Position).magnitude)
            end
            par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + Vector3.new(0, 1.2 - i * 0.06, 0))
            if par == nil then
              par2, locy = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + Vector3.new(0, 1.2 - i * 0.06, 0))
              RootPart.CFrame = RootPart.CFrame - (RootPart.Position - locy) * 1
            else
              RootPart.CFrame = RootPart.CFrame - Vector3.new(0, 1, 0) * (2 - (loc - RootPart.Position).magnitude)
            end
            if i <= 31 then
              bustTarget.HumanoidRootPart.CFrame = CFrame.new((LeftArm.CFrame * CFrame.new(0, -2.5, 0)).p:lerp((RightArm.CFrame * CFrame.new(0, -2.5, 0)).p, 0.5 + (i - 21) * 0.05), Torso.Position) * CFrame.Angles(0, 0, -math.pi / 2)
            else
              vvel = vvel * 0.99
              bustTarget.HumanoidRootPart.CFrame = RightArm.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(math.pi / 2, 0, math.pi)
            end
            par, loc = drawline_a(RootPart.Position, RootPart.Position - Vector3.new(0, 5, 0))
            if par or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
              break
            end
          end
          if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            gval:Destroy()
            if vvel and type(vvel) ~= "number" then
              vvel:Destroy()
            end
            RootPart.Anchored = false
            workspace.suppFunc:FireServer(stats, false, 0)
            dec:Destroy()
            bustTarget.HumanoidRootPart.Anchored = false
            grabbing = false
            attack = false
            resumeControl()
            Humanoid.AutoRotate = true
            return
          end
          if not par then
            etime = time()
            repeat
              swait()
              k = k + 0.5
              z = z ^ 1.09
              if z > 2.5 then
                z = 2.5
              end
              par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + vdir * 5)
              if par == nil then
                par2, locx = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + vdir * vvel)
                RootPart.CFrame = RootPart.CFrame - (RootPart.Position - locx) * 1
              else
                RootPart.CFrame = RootPart.CFrame - vdir * (4.9 - (loc - RootPart.Position).magnitude)
              end
              par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + Vector3.new(0, 1.2 - k * 0.06 - z * 0.01, 0))
              if par == nil then
                par2, locy = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p + Vector3.new(0, 1.2 - k * 0.06 - z * 0.01, 0))
                RootPart.CFrame = RootPart.CFrame - (RootPart.Position - locy) * 1
              else
                RootPart.CFrame = RootPart.CFrame - Vector3.new(0, 1, 0) * (2 - (loc - RootPart.Position).magnitude)
              end
              vvel = vvel * 0.97
              bustTarget.HumanoidRootPart.CFrame = RightArm.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(math.pi / 2, 0, math.pi)
              par, loc = drawline_a(RootPart.Position, RootPart.Position - Vector3.new(0, 5, 0))
              if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
                break
              end
              if 2 < time() - etime then
                break
              end
            until par ~= nil or 0 >= Humanoid.Health or Stunned.Value == true or Stun.Value >= StunT.Value or Suppressed.Value == true
          end
          RootPart.CFrame = CFrame.new(loc, loc + vdir * 5) * CFrame.Angles(math.rad(-10), 0, 0) + Vector3.new(0, 4.5, 0)
          if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            gval:Destroy()
            if vvel and type(vvel) ~= "number" then
              vvel:Destroy()
            end
            RootPart.Anchored = false
            workspace.suppFunc:FireServer(stats, false, 0)
            dec:Destroy()
            bustTarget.HumanoidRootPart.Anchored = false
            grabbing = false
            attack = false
            resumeControl()
            Humanoid.AutoRotate = true
            return
          end
          for i = 1, 8 do
            swait()
            if TimeLocked.Value == true then
              repeat
                game:GetService("RunService").Heartbeat:wait()
              until TimeLocked.Value == false or Suppressed.Value == true
            end
            RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, -1.2) * CFrame.fromEulerAnglesXYZ(math.rad(50), -math.rad(10), math.rad(40)), 0.55)
            Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(-30)), 0.55)
            RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.3, -0.3, -0.3) * CFrame.fromEulerAnglesXYZ(math.rad(-20), math.rad(-30), math.rad(50)), 0.55)
            RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.55)
            LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-40), math.rad(40), math.rad(-80)), 0.55)
            LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.55)
            RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0.3, 0) * CFrame.Angles(math.rad(-30), math.rad(-40), -math.rad(50)), 0.55)
            LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.9, 0, -0.4) * CFrame.Angles(math.rad(0), math.rad(-40), math.rad(15)), 0.55)
            if i <= 2 then
              RootPart.CFrame = RootPart.CFrame - Vector3.new(0, 0.7, 0) + vdir * vvel
              bustTarget.HumanoidRootPart.CFrame = RightArm.CFrame * CFrame.new(0, -2, 0) * CFrame.Angles(math.pi / 2, 0, math.pi)
            elseif i == 3 then
              workspace.suppFunc:FireServer(stats, false, 0)
              Damagefunc(bustTarget.Torso, 0, 35, 0, 20, RootPart, 0, "Normal", 20, false, false, false)
              bustTarget.HumanoidRootPart.CFrame = RootPart.CFrame + vdir * 2
              workspace.suppFunc:FireServer(stats, false, 0)
              bustTarget.HumanoidRootPart.Anchored = false
              Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
              so("471882019", RootPart, 0.8, 1.7)
              so("314970799", RootPart, 0.8, 1.7)
              RootPart.Anchored = false
              bustTarget.Torso.Anchored = false
              local xd, sc
              for _, v in pairs(game.Players:children()) do
                if v.Character and v.Character:FindFirstChild("Torso") then
                  xd = (v.Character.Torso.Position - RootPart.Position).magnitude
                  if xd <= 30 then
                    sc = script.CamShake:clone()
                    sc.intensity.Value = 15 - xd / 3
                    sc.times.Value = 15
                    sc.Disabled = false
                    sc.Parent = v.Character
                  end
                end
              end
              local pc = Instance.new("Part", workspace)
              pc.BrickColor = BrickColor:White()
              local m = Instance.new("SpecialMesh", pc)
              m.Scale = Vector3.new(11, 5, 11)
              pc.Anchored = true
              pc.CanCollide = false
              pc.Size = Vector3.new(0.2, 0.2, 0.2)
              pc.Mesh.MeshType = "FileMesh"
              pc.Anchored = true
              pc.CanCollide = false
              pc.Parent = workspace
              pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415447"
              pc.Name = "Shockwave"
              game:GetService("Debris"):AddItem(pc, 5)
              pc.CFrame = CFrame.new(drawline_b(bustTarget.Torso.Position + Vector3.new(0, 2, 0), bustTarget.Torso.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 2.5, 0))
              coroutine.resume(coroutine.create(function(p, x)
                for i = 1, 20 do
                  p.Transparency = 0.35 + i / 30.769230769230766
                  p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0) - Vector3.new(0, 0.1, 0)
                  p.Mesh.Scale = p.Mesh.Scale + Vector3.new(0.4, -0.2, 0.4)
                  swait()
                end
                p:Remove()
              end), pc, 6)
              local pc = Instance.new("Part", workspace)
              pc.BrickColor = BrickColor:White()
              local m = Instance.new("SpecialMesh", pc)
              m.Scale = Vector3.new(7, 10, 7)
              pc.Anchored = true
              pc.CanCollide = false
              pc.Size = Vector3.new(0.2, 0.2, 0.2)
              pc.Mesh.MeshType = "FileMesh"
              pc.Anchored = true
              pc.CanCollide = false
              pc.Parent = workspace
              pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415572"
              pc.Name = "Shockwave"
              game:GetService("Debris"):AddItem(pc, 5)
              pc.CFrame = CFrame.new(drawline_b(bustTarget.Torso.Position + Vector3.new(0, 2, 0), bustTarget.Torso.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 4, 0))
              coroutine.resume(coroutine.create(function(p, x)
                for i = 1, 20 do
                  p.Transparency = 0.35 + i / 30.769230769230766
                  p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(2 + i), 0) - Vector3.new(0, 0.25, 0)
                  p.Mesh.Scale = p.Mesh.Scale + Vector3.new(0.3, -0.5, 0.3)
                  swait()
                end
                p:Remove()
              end), pc, 6)
            end
            if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health and i > 3 then
              break
            end
          end
          bustTarget.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
          workspace.CurrentCamera.CameraType = "Custom"
          gval:Destroy()
          RootPart.Anchored = false
          bustTarget.HumanoidRootPart.Anchored = false
          game:GetService("Debris"):AddItem(gval, 1.25)
        end
      end
      Humanoid.AutoRotate = true
      grabbing = false
    elseif sattack == "LandGrab" then
      attack = true
      stance = false
      grabbing = true
      local par, loc
      local etime = time()
      repeat
        swait()
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        if 2 < time() - etime then
          break
        end
        par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p - Vector3.new(0, 3.3, 0))
      until par ~= nil or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or 0 >= Humanoid.Health
      for i = 1, 10 do
        swait()
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.1, -0.4) * CFrame.fromEulerAnglesXYZ(math.rad(10), math.rad(0), math.rad(-40)), 0.3)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(5), math.rad(5), math.rad(25)), 0.3)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(-0.35, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(20), math.rad(90)), 0.3)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.3)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-20), math.rad(-90)), 0.3)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.3)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.6, 0.3, -0.15) * CFrame.Angles(math.rad(0), math.rad(30), math.rad(0)), 0.3)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0.2, 0.3) * CFrame.Angles(math.rad(0), math.rad(50), math.rad(20)), 0.3)
        if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
          break
        end
      end
      if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
        RootPart.Anchored = false
        grabbing = false
        attack = false
        resumeControl()
        Humanoid.AutoRotate = true
        dec:Destroy()
        return
      end
      bustTarget = nil
      Humanoid.AutoRotate = false
      local vcdir = RootPart.CFrame.lookVector
      local vvel = Instance.new("BodyVelocity")
      vvel.P = 300
      vvel.maxForce = Vector3.new(26500, 0, 26500)
      vvel.Parent = RootPart
      for i = 1, 10 do
        swait()
        local vp, t, loc, par, mag
        if Rooted.Value == true then
          vvel.P = 0
          vvel.maxForce = Vector3.new(0, 0, 0)
        else
          vvel.P = 300
          vvel.maxForce = Vector3.new(26500, 0, 26500)
        end
        vvel.velocity = vcdir * (52.5 - i * 3.85)
        if i >= 2 and i <= 10 then
          for _, v in pairs(workspace:children()) do
            if v.className == "Model" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") then
              t = v.HumanoidRootPart
              vp = game.Players:GetPlayerFromCharacter(v)
              if vp == nil then
                if v:FindFirstChild("Alignment") then
                  if v.Alignment.Value ~= Player.TeamColor or Player.Neutral == true then
                    mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -0.5, 0)).p).magnitude
                    if mag <= 4.85 then
                      par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5, 0))
                      if par ~= nil then
                        print("GOE")
                        bustTarget = v
                      end
                    end
                  end
                else
                  mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -0.5, 0)).p).magnitude
                  if mag <= 4.85 then
                    par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5, 0))
                    if par ~= nil then
                      print("GOE")
                      bustTarget = v
                    end
                  end
                end
              elseif vp.TeamColor ~= Player.TeamColor or Player.Neutral == true and vp.Neutral == true and vp ~= Player then
                mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -0.5, 0)).p).magnitude
                if mag <= 4.85 then
                  par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5, 0))
                  if par ~= nil then
                    print("GOE")
                    bustTarget = v
                  end
                end
              end
            end
          end
        end
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, -0.4) * CFrame.fromEulerAnglesXYZ(math.rad(10), math.rad(0), math.rad(60)), 0.45)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(15), math.rad(-5), math.rad(-35)), 0.45)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(1, 0.15, 0.1) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-55), math.rad(100)), 0.45)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, -0.2, -0.1) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.45)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.5, -0.05, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(70), math.rad(-70)), 0.45)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.45)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0.4, 0.1) * CFrame.Angles(math.rad(0), math.rad(-55), -math.rad(7)), 0.45)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.5, 0.2, -0.2) * CFrame.Angles(math.rad(-5), math.rad(-50), math.rad(15)), 0.45)
        if bustTarget or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
          break
        end
      end
      vvel:Destroy()
      if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
        RootPart.Anchored = false
        grabbing = false
        attack = false
        resumeControl()
        Humanoid.AutoRotate = true
        dec:Destroy()
        return
      end
      if bustTarget then
        local stats = bustTarget:FindFirstChild("Stats")
        if stats and stats:FindFirstChild("Ulting") and stats.Ulting.Value == false and stats:FindFirstChild("Grabbed") == nil then
          local gval = Instance.new("StringValue", stats)
          gval.Name = "Grabbed"
          gval.Value = Player.Name
          stats.Suppressed.Value = true
          workspace.suppFunc:FireServer(stats, true, 10)
          so("200632821", bustTarget.HumanoidRootPart, 1, 1)
          bustTarget.HumanoidRootPart.Anchored = true
          bustTarget.HumanoidRootPart.CFrame = RightArm.CFrame * CFrame.new(0, -2.15, 0) * CFrame.Angles(math.pi / 2, 0, math.pi)
          local vvel = 0.1
          workspace.CurrentCamera.CameraType = "Track"
          RootPart.Anchored = true
          par, loc = drawline_a(RootPart.Position, RootPart.Position + vcdir * 7)
          if par then
            RootPart.CFrame = RootPart.CFrame - vcdir * (7 - (RootPart.Position - loc).magnitude)
          end
          for i = 1, 12 do
            swait()
            if TimeLocked.Value == true then
              repeat
                game:GetService("RunService").Heartbeat:wait()
              until TimeLocked.Value == false or Suppressed.Value == true
            end
            RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 1.1, -0.2) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(10), math.rad(-20)), 0.35)
            Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(15), math.rad(5), math.rad(25)), 0.35)
            RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(-0.35, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(40), math.rad(190)), 0.35)
            RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
            LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(40), math.rad(-90)), 0.35)
            LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
            RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.5, 0.1, -0.15) * CFrame.Angles(math.rad(5), math.rad(30), math.rad(0)), 0.45)
            LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0.35, 0.1) * CFrame.Angles(math.rad(-15), math.rad(20), math.rad(0)), 0.45)
            bustTarget.HumanoidRootPart.CFrame = RightArm.CFrame * CFrame.new(0, -2.15, 0) * CFrame.Angles(math.pi / 2, 0, math.pi * 0.9)
            if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
              break
            end
          end
          if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            gval:Destroy()
            if vvel and type(vvel) ~= "number" then
              vvel:Destroy()
            end
            RootPart.Anchored = false
            workspace.suppFunc:FireServer(stats, false, 0)
            dec:Destroy()
            bustTarget.HumanoidRootPart.Anchored = false
            grabbing = false
            attack = false
            resumeControl()
            Humanoid.AutoRotate = true
            return
          end
          etime = time()
          repeat
            swait()
            par, loc = drawline_a(RootPart.Position, RootPart.Position - Vector3.new(0, 5, 0))
            if 2 < time() - etime then
              break
            end
          until par ~= nil or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health
          if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            gval:Destroy()
            if vvel and type(vvel) ~= "number" then
              vvel:Destroy()
            end
            RootPart.Anchored = false
            workspace.suppFunc:FireServer(stats, false, 0)
            dec:Destroy()
            bustTarget.HumanoidRootPart.Anchored = false
            grabbing = false
            attack = false
            resumeControl()
            Humanoid.AutoRotate = true
            return
          end
          for i = 1, 12 do
            swait()
            if TimeLocked.Value == true then
              repeat
                game:GetService("RunService").Heartbeat:wait()
              until TimeLocked.Value == false or Suppressed.Value == true
            end
            RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, -0.6, -1) * CFrame.fromEulerAnglesXYZ(math.rad(30), math.rad(-10), math.rad(20)), 0.55)
            Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(15), math.rad(5), math.rad(0)), 0.55)
            RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, -0.2, -0.1) * CFrame.fromEulerAnglesXYZ(math.rad(-10), math.rad(-20), math.rad(50)), 0.55)
            RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.55)
            LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.3, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(70), math.rad(-90)), 0.55)
            LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.55)
            RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.5, 0.1, 0.15) * CFrame.Angles(math.rad(-10), math.rad(-20), math.rad(-55)), 0.55)
            LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.2, 0.35, 0.1) * CFrame.Angles(math.rad(-15), math.rad(-20), math.rad(0)), 0.55)
            if i <= 2 then
              bustTarget.HumanoidRootPart.CFrame = RightArm.CFrame * CFrame.new(0, -2.15, 0) * CFrame.Angles(math.pi / 2, 0, math.pi * 0.9)
            elseif i == 3 then
              workspace.suppFunc:FireServer(stats, false, 0)
              Damagefunc(bustTarget.Torso, 0, 22.5, 0, 30, RootPart, 0, "Normal", 20, false, false, false)
              bustTarget.HumanoidRootPart.CFrame = RootPart.CFrame + RootPart.CFrame.lookVector * 2.5
              bustTarget.HumanoidRootPart.Anchored = false
              so("471882019", RootPart, 0.8, 1.8)
              so("314970799", RootPart, 0.7, 2)
              RootPart.Anchored = false
              bustTarget.Torso.Anchored = false
              local xd, sc
              for _, v in pairs(game.Players:children()) do
                if v.Character and v.Character:FindFirstChild("Torso") then
                  xd = (v.Character.Torso.Position - RootPart.Position).magnitude
                  if xd <= 30 then
                    sc = script.CamShake:clone()
                    sc.intensity.Value = 10 - xd / 4
                    sc.times.Value = 12
                    sc.Disabled = false
                    sc.Parent = v.Character
                  end
                end
              end
              local pc = Instance.new("Part", workspace)
              pc.BrickColor = BrickColor:White()
              local m = Instance.new("SpecialMesh", pc)
              m.Scale = Vector3.new(8, 5, 8)
              pc.Anchored = true
              pc.CanCollide = false
              pc.Size = Vector3.new(0.2, 0.2, 0.2)
              pc.Mesh.MeshType = "FileMesh"
              pc.Anchored = true
              pc.CanCollide = false
              pc.Parent = workspace
              pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415447"
              pc.Name = "Shockwave"
              game:GetService("Debris"):AddItem(pc, 5)
              pc.CFrame = CFrame.new(drawline_b(bustTarget.Torso.Position + Vector3.new(0, 2, 0), bustTarget.Torso.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 2.5, 0))
              coroutine.resume(coroutine.create(function(p, x)
                for i = 1, 20 do
                  p.Transparency = 0.35 + i / 30.769230769230766
                  p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(2 + i), 0) - Vector3.new(0, 0.1, 0)
                  p.Mesh.Scale = p.Mesh.Scale + Vector3.new(0.3, -0.2, 0.3)
                  swait()
                end
                p:Remove()
              end), pc, 6)
              local pc = Instance.new("Part", workspace)
              pc.BrickColor = BrickColor:White()
              local m = Instance.new("SpecialMesh", pc)
              m.Scale = Vector3.new(4, 10, 4)
              pc.Anchored = true
              pc.CanCollide = false
              pc.Size = Vector3.new(0.2, 0.2, 0.2)
              pc.Mesh.MeshType = "FileMesh"
              pc.Anchored = true
              pc.CanCollide = false
              pc.Parent = workspace
              pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415572"
              pc.Name = "Shockwave"
              game:GetService("Debris"):AddItem(pc, 5)
              pc.CFrame = CFrame.new(drawline_b(bustTarget.Torso.Position + Vector3.new(0, 2, 0), bustTarget.Torso.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 4, 0))
              coroutine.resume(coroutine.create(function(p, x)
                for i = 1, 20 do
                  p.Transparency = 0.35 + i / 30.769230769230766
                  p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0) - Vector3.new(0, 0.25, 0)
                  p.Mesh.Scale = p.Mesh.Scale + Vector3.new(0.2, -0.5, 0.2)
                  swait()
                end
                p:Remove()
              end), pc, 6)
            end
            if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health and i > 3 then
              break
            end
          end
          bustTarget.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
          workspace.CurrentCamera.CameraType = "Custom"
          gval:Destroy()
          RootPart.Anchored = false
          bustTarget.HumanoidRootPart.Anchored = false
          game:GetService("Debris"):AddItem(gval, 1.25)
        end
      end
      Humanoid.AutoRotate = true
      grabbing = false
    elseif sattack == "ThrowGrab" then
      attack = true
      stance = false
      grabbing = true
      do
        local par, loc
        local etime = time()
        repeat
          swait()
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if 2 < time() - etime then
            break
          end
          par, loc = drawline_a(RootPart.CFrame.p, RootPart.CFrame.p - Vector3.new(0, 3.3, 0))
        until par ~= nil or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health
        for i = 1, 8 do
          swait()
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, -0.1) * CFrame.fromEulerAnglesXYZ(math.rad(-10), math.rad(0), math.rad(0)), 0.3)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(15), math.rad(0), math.rad(0)), 0.3)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-20), math.rad(70)), 0.3)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.3)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(20), math.rad(-70)), 0.3)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.3)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0.08, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.3, 0.08, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(18)), 0.3)
          if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            break
          end
        end
        if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
          RootPart.Anchored = false
          grabbing = false
          attack = false
          resumeControl()
          Humanoid.AutoRotate = true
          dec:Destroy()
          return
        end
        bustTarget = nil
        Humanoid.AutoRotate = false
        local vcdir = RootPart.CFrame.lookVector
        vcdir = Vector3.new(vcdir.x, 0, vcdir.z).unit
        local vvel = Instance.new("BodyVelocity")
        vvel.P = 300
        vvel.maxForce = Vector3.new(26500, 0, 26500)
        vvel.Parent = RootPart
        local vp, t, loc, par, mag
        for i = 1, 10 do
          swait()
          if Rooted.Value == true then
            vvel.P = 0
            vvel.maxForce = Vector3.new(0, 0, 0)
          else
            vvel.P = 300
            vvel.maxForce = Vector3.new(26500, 0, 26500)
          end
          vvel.velocity = vcdir * (22.5 - i * 1.9)
          if i >= 2 and i <= 10 then
            for _, v in pairs(workspace:children()) do
              if v.className == "Model" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") then
                t = v.HumanoidRootPart
                vp = game.Players:GetPlayerFromCharacter(v)
                if vp == nil then
                  if v:FindFirstChild("Alignment") then
                    if v.Alignment.Value ~= Player.TeamColor or Player.Neutral == true then
                      mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -0.5, 0)).p).magnitude
                      if mag <= 4.85 then
                        par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5, 0))
                        if par ~= nil then
                          print("GOE")
                          bustTarget = v
                        end
                      end
                    end
                  else
                    mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -0.5, 0)).p).magnitude
                    if mag <= 4.85 then
                      par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5, 0))
                      if par ~= nil then
                        print("GOE")
                        bustTarget = v
                      end
                    end
                  end
                elseif vp.TeamColor ~= Player.TeamColor or Player.Neutral == true and vp.Neutral == true and vp ~= Player then
                  mag = (t.Position - (RightArm.CFrame * CFrame.new(0, -0.5, 0)).p).magnitude
                  if mag <= 4.85 then
                    par, loc = drawline_a(t.Position, t.Position - Vector3.new(0, 5, 0))
                    if par ~= nil then
                      print("GOE")
                      bustTarget = v
                    end
                  end
                end
              end
            end
          end
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, -0.4) * CFrame.fromEulerAnglesXYZ(math.rad(30), math.rad(0), math.rad(0)), 0.45)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-15), math.rad(0), math.rad(0)), 0.45)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.4, 0.2, -0.3) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(20), math.rad(110)), 0.45)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.45)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.4, 0.2, -0.3) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-20), math.rad(-110)), 0.45)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.45)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0.08, 0) * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(0)), 0.45)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.5, 0.6, 0) * CFrame.Angles(math.rad(-4), math.rad(0), -math.rad(18)), 0.45)
          if bustTarget or Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
            break
          end
        end
        vvel:Destroy()
        if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
          RootPart.Anchored = false
          grabbing = false
          attack = false
          resumeControl()
          Humanoid.AutoRotate = true
          dec:Destroy()
          return
        end
        if bustTarget then
          local stats = bustTarget:FindFirstChild("Stats")
          if stats and stats:FindFirstChild("Ulting") and stats.Ulting.Value == false and stats:FindFirstChild("Grabbed") == nil then
            local gval = Instance.new("StringValue", stats)
            gval.Name = "Grabbed"
            gval.Value = Player.Name
            Humanoid.AutoRotate = true
            stats.Suppressed.Value = true
            workspace.suppFunc:FireServer(stats, true, 10)
            so("200632821", bustTarget.HumanoidRootPart, 1, 1)
            bustTarget.HumanoidRootPart.Anchored = true
            bustTarget.HumanoidRootPart.CFrame = Torso.CFrame * CFrame.new(0, 1, -2.2) * CFrame.Angles(0, math.pi, 0)
            workspace.CurrentCamera.CameraType = "Track"
            RootPart.Anchored = true
            RootPart.CFrame = CFrame.new(RootPart.Position, RootPart.Position + vcdir * 5)
            local lcf = RootPart.CFrame
            for i = 1, 18 do
              swait()
              if TimeLocked.Value == true then
                repeat
                  game:GetService("RunService").Heartbeat:wait()
                until TimeLocked.Value == false or Suppressed.Value == true
              end
              if Player:FindFirstChild("ShiftLockEnabled") == nil then
                RootPart.CFrame = CFrame.new(lcf.p, Vector3.new(MMouse.hit.p.x, lcf.p.y, MMouse.hit.p.z))
              end
              RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0, -0.3) * CFrame.fromEulerAnglesXYZ(math.rad(20), math.rad(0), math.rad(0)), 0.35)
              Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(-5), math.rad(0), math.rad(0)), 0.35)
              RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.2, 0.1, -0.1) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(20), math.rad(90)), 0.35)
              RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
              LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.2, 0.1, -0.1) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-20), math.rad(-90)), 0.35)
              LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
              RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0.08, 0) * CFrame.Angles(math.rad(-2), math.rad(0), math.rad(-12)), 0.45)
              LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.5, 0.5, 0) * CFrame.Angles(math.rad(-2), math.rad(0), -math.rad(15)), 0.45)
              bustTarget.HumanoidRootPart.CFrame = Torso.CFrame * CFrame.new(0, 1, -2.2) * CFrame.Angles(0, math.pi, 0)
              if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
                break
              end
            end
            if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
              gval:Destroy()
              if vvel and type(vvel) ~= "number" then
                vvel:Destroy()
              end
              RootPart.Anchored = false
              workspace.suppFunc:FireServer(stats, false, 0)
              dec:Destroy()
              bustTarget.HumanoidRootPart.Anchored = false
              grabbing = false
              attack = false
              resumeControl()
              Humanoid.AutoRotate = true
              return
            end
            Humanoid.AutoRotate = false
            vcdir = RootPart.CFrame.lookVector
            vcdir = Vector3.new(vcdir.x, 0, vcdir.z).unit
            par, loc = drawline_a(RootPart.Position, RootPart.Position + vcdir * 8.5)
            if par then
              RootPart.CFrame = RootPart.CFrame - vcdir * (8.5 - (RootPart.Position - loc).magnitude)
            end
            for i = 1, 30 do
              swait()
              if i % 9 == 0 then
                so("543314768", RootPart, 0.3, 0.4 + i / 8 * 0.05)
                so("541546847", RootPart, 0.6, 0.7 + i / 8 * 0.05)
              end
              if TimeLocked.Value == true then
                repeat
                  game:GetService("RunService").Heartbeat:wait()
                until TimeLocked.Value == false or Suppressed.Value == true
              end
              RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 1.6, -0.35) * CFrame.fromEulerAnglesXYZ(math.rad(-30), math.rad(0), math.rad(0)), 0.3)
              Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(15), math.rad(0), math.rad(0)), 0.3)
              RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.6, -0.2, -0.6) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(6), math.rad(65)), 0.3)
              RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.3)
              LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.6, -0.2, -0.6) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-6), math.rad(-65)), 0.3)
              LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.3)
              RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-2), math.rad(0), math.rad(-7)), 0.3)
              LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-2), math.rad(0), math.rad(3)), 0.3)
              if i <= 5 then
                bustTarget.HumanoidRootPart.CFrame = (Torso.CFrame * CFrame.new(0, 1, -2.2) * CFrame.Angles(0, math.pi, 0)):lerp(Torso.CFrame * CFrame.new(0, -2, -5.8) * CFrame.Angles(-math.pi / 2 - math.rad(25), math.pi, 0), 0.2 * i)
              else
                bustTarget.HumanoidRootPart.CFrame = Torso.CFrame * CFrame.new(0, -2, -5.8) * CFrame.Angles(-math.pi / 2 - math.rad(25), math.pi, 0)
              end
              RootPart.CFrame = RootPart.CFrame * CFrame.Angles(0, math.rad(i * 2.32), 0)
              if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
                break
              end
            end
            if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health then
              gval:Destroy()
              if vvel and type(vvel) ~= "number" then
                vvel:Destroy()
              end
              if vvel and type(vvel) ~= "number" then
                vvel:Destroy()
              end
              RootPart.Anchored = false
              workspace.suppFunc:FireServer(stats, false, 0)
              dec:Destroy()
              bustTarget.HumanoidRootPart.Anchored = false
              grabbing = false
              attack = false
              resumeControl()
              Humanoid.AutoRotate = true
              return
            end
            for i = 1, 12 do
              swait()
              if TimeLocked.Value == true then
                repeat
                  game:GetService("RunService").Heartbeat:wait()
                until TimeLocked.Value == false or Suppressed.Value == true
              end
              RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 1.9, -0.35) * CFrame.fromEulerAnglesXYZ(math.rad(-35), math.rad(0), math.rad(0)), 0.35)
              Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(15), math.rad(0), math.rad(0)), 0.35)
              RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.4, 0, 0.3) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(-56), math.rad(65)), 0.35)
              RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
              LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.4, 0, 0.3) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(56), math.rad(-65)), 0.35)
              LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.fromEulerAnglesXYZ(math.rad(0), math.rad(0), math.rad(0)), 0.35)
              RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-2), math.rad(0), math.rad(-22)), 0.35)
              LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0.2, 0) * CFrame.Angles(math.rad(-2), math.rad(0), math.rad(43)), 0.35)
              if i == 1 then
                bustTarget.HumanoidRootPart.CFrame = Torso.CFrame * CFrame.new(0, -2, -5.8) * CFrame.Angles(-math.pi / 2 - math.rad(25), math.pi, 0)
                coroutine.resume(coroutine.create(function(t, v, st, h, gval)
                  local ttime = tick()
                  local sc = script.Failsafe:clone()
                  sc.Parent = t
                  sc.Disabled = false
                  local e, s = 0, 0
                  local par, loc, nor, par2, loc2, nor2
                  etime = time()
                  repeat
                    s = swait()
                    par2, loc2, nor2 = drawline_a(t.Position, t.Position + v.unit * 5)
                    if par2 == nil then
                      par, loc, nor = drawline_a(t.Position, t.Position + v * s)
                      v = v * 0.91 - Vector3.new(0, 1.5, 0)
                      t.CFrame = CFrame.new(t.Position + (loc - t.Position), t.Position + (loc - t.Position) + v.unit * 0.1) * CFrame.Angles(-math.pi / 2, 0, 0)
                    end
                    if time() - etime > 2 then
                      break
                    end
                  until par or par2 or e > 0.25 or sc.Parent == nil or 0 >= Humanoid.Health or 0 >= h.Health or t.Anchored == false
                  if par2 then
                    t.CFrame = CFrame.new(loc2 + nor2 * 2 - v.unit * 0.1, loc2)
                    st.Suppressed.Value = false
                    st.Suppressed.Timer.Value = 0
                    Damagefunc(t, 0, 18.5, 0, 0, RootPart, 0, "None", 30, true, false, false)
                    t.Velocity = -v.unit * 10
                    --workspace.kbFunc:FireServer(t, -v.unit * 10)
                    local pc = Instance.new("Part", workspace)
                    pc.BrickColor = BrickColor:White()
                    local m = Instance.new("SpecialMesh", pc)
                    m.Scale = Vector3.new(4, 5, 4)
                    pc.Anchored = true
                    pc.CanCollide = false
                    pc.Size = Vector3.new(0.2, 0.2, 0.2)
                    pc.Mesh.MeshType = "FileMesh"
                    pc.Anchored = true
                    pc.CanCollide = false
                    pc.Parent = workspace
                    pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415286"
                    pc.Name = "Shockwave"
                    game:GetService("Debris"):AddItem(pc, 5)
                    pc.CFrame = CFrame.new(loc2, loc2 + nor2.unit * 5) * CFrame.Angles(-math.pi / 2, 0, 0) + loc2.unit * 1.5
                    coroutine.resume(coroutine.create(function(p, x)
                      for i = 1, 10 do
                        p.Transparency = 0.35 + i / 15.384615384615383
                        p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0)
                        p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1, 0, 1)
                        swait()
                      end
                      p:Remove()
                    end), pc, 6)
                    so("471882019", t, 0.7, 2)
                    so("314970799", t, 0.7, 1.5)
                  else
                    if par == nil then
                      t.Velocity = v.unit * 20
                      --workspace.kbFunc:FireServer(t, v.unit * 20)
                    else
                      t.CFrame = CFrame.new(loc + nor * 2 - v.unit * 0.1, loc)
                      st.Suppressed.Value = false
                      st.Suppressed.Timer.Value = 0
                      Damagefunc(t, 0, 18.5, 0, 0, RootPart, 0, "None", 30, true, false, false)
                      t.Velocity = -v.unit * 10
                      --workspace.kbFunc:FireServer(t, -v.unit * 10)
                      local pc = Instance.new("Part", workspace)
                      pc.BrickColor = BrickColor:White()
                      local m = Instance.new("SpecialMesh", pc)
                      m.Scale = Vector3.new(4, 5, 4)
                      pc.Anchored = true
                      pc.CanCollide = false
                      pc.Size = Vector3.new(0.2, 0.2, 0.2)
                      pc.Mesh.MeshType = "FileMesh"
                      pc.Anchored = true
                      pc.CanCollide = false
                      pc.Parent = workspace
                      pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415286"
                      pc.Name = "Shockwave"
                      game:GetService("Debris"):AddItem(pc, 5)
                      pc.CFrame = CFrame.new(loc, loc + nor.unit * 5) * CFrame.Angles(-math.pi / 2, 0, 0) + loc2.unit * 2
                      coroutine.resume(coroutine.create(function(p, x)
                        for i = 1, 10 do
                          p.Transparency = 0.35 + i / 15.384615384615383
                          p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0)
                          p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1, 0, 1)
                          swait()
                        end
                        p:Remove()
                      end), pc, 6)
                      so("471882019", t, 0.7, 2)
                      so("314970799", t, 0.7, 1.5)
                    end
                    workspace.suppFunc:FireServer(st, false, 0)
                  end
                  t.Anchored = false
                  gval:Destroy()
                  if vvel and type(vvel) ~= "number" then
                    vvel:Destroy()
                  end
                end), bustTarget.HumanoidRootPart, vcdir * 110 + Vector3.new(0, 5, 0), stats, bustTarget.Humanoid, gval)
              end
              if Stun.Value >= StunT.Value or Stun.Value == true or Suppressed.Value == true or 0 >= Humanoid.Health and i > 2 then
                break
              end
            end
            game:GetService("Debris"):AddItem(gval, 1.25)
            bustTarget.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            workspace.CurrentCamera.CameraType = "Custom"
            gval:Destroy()
            RootPart.Anchored = false
            dec:Destroy()
            bustTarget.HumanoidRootPart.Anchored = false
          end
        end
        Humanoid.AutoRotate = true
        grabbing = false
      end
    end
    Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    dec.Parent = nil
    attack = false
    resumeControl()
  end
end
function do3()
  if attack == true then
    return
  end
  if attack == true or equipped == false or Stunned.Value == true or Stagger.Value == true or Unstable.Value == true or Suppressed.Value == true then
    return
  end
  if cooldowns[3] >= cooldownmax and mana.Value >= 20 then
    attack = true
    cooldowns[3] = 0
    mana.Value = mana.Value - 20
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 50
    for i = 1, 8 do
      swait()
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(2, 0, -1.2), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.3, 0, 1), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1.1, -1, 0) * euler(0, 1.57, -0.1), 0.25)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0.1), 0.25)
      if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
        break
      end
    end
    for i = 1, 8 do
      swait()
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 0), 0.35)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.2, 0, 0), 0.35)
      RW.C0 = clerp(RW.C0, cf(1.2, 0.8, 0) * euler(3.5, 0, -0.3), 0.35)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.35)
      LW.C0 = clerp(LW.C0, cf(-1.2, 0.8, 0) * euler(3.4, 0, 0.4), 0.35)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.35)
      RH.C0 = clerp(RH.C0, cf(1.1, -0.8, 0.2) * euler(0, 1.57, -0.2), 0.35)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0.3), 0.35)
      if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
        break
      end
    end
    local et = 0
    while hitfloor == nil do
      swait()
      et = et + 1
      if et >= 70 then
        break
      end
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
        break
      end
    end
    for i = 1, 5 do
      swait()
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.2, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.2, 0.3, 0) * euler(0.8, 0, -0.4), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.2, 0.3, 0) * euler(0.8, 0, 0.4), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, 0.2, -0.4) * euler(0, 1.57, -0.6) * euler(-0.2, 0, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, 0.1, -0.5) * euler(0, -1.57, 0.2), 0.4)
      if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
        break
      end
    end
    if Stagger.Value == true or Stun.Value >= StunT.Value or StaggerHit.Value == true then
    else
      so("200632561", RightLeg, 1, 1)
      DecreaseStat(Character, "Defense", -0.1, 150)
      local pc = Instance.new("Part", workspace)
      pc.BrickColor = BrickColor:White()
      local m = Instance.new("SpecialMesh", pc)
      m.Scale = Vector3.new(6, 2, 6)
      pc.Anchored = true
      pc.CanCollide = false
      pc.Size = Vector3.new(0.2, 0.2, 0.2)
      pc.Mesh.MeshType = "FileMesh"
      pc.Anchored = true
      pc.CanCollide = false
      pc.Parent = workspace
      pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415286"
      pc.Name = "Shockwave"
      game:GetService("Debris"):AddItem(pc, 5)
      pc.CFrame = CFrame.new(drawline_b(RootPart.Position + RootPart.CFrame.lookVector * 2, RootPart.Position + RootPart.CFrame.lookVector * 2 - Vector3.new(0, 30, 0))) + Vector3.new(0, 0.6, 0)
      coroutine.resume(coroutine.create(function(p, x)
        for i = 1, 14 do
          p.Transparency = 0.5 + i / 28
          p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(2 + i), 0) - Vector3.new(0, 0.03571428571428571, 0)
          p.Mesh.Scale = p.Mesh.Scale + Vector3.new(2.2, -0.07142857142857142, 2.2)
          swait()
        end
        p:Remove()
      end), pc, 5)
      local pc = Instance.new("Part", workspace)
      pc.BrickColor = BrickColor:White()
      local m = Instance.new("SpecialMesh", pc)
      m.Scale = Vector3.new(3, 8, 3)
      pc.Anchored = true
      pc.CanCollide = false
      pc.Size = Vector3.new(0.2, 0.2, 0.2)
      pc.Mesh.MeshType = "FileMesh"
      pc.Anchored = true
      pc.CanCollide = false
      pc.Parent = workspace
      pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415447"
      pc.Name = "Shockwave"
      game:GetService("Debris"):AddItem(pc, 5)
      pc.CFrame = CFrame.new(drawline_b(RootPart.Position + RootPart.CFrame.lookVector * 2, RootPart.Position + RootPart.CFrame.lookVector * 2 - Vector3.new(0, 30, 0))) + Vector3.new(0, 2.5, 0)
      coroutine.resume(coroutine.create(function(p, x)
        for i = 1, 16 do
          p.Transparency = 0.5 + i / 32
          p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(1 + i), 0) - Vector3.new(0, 0.15625, 0)
          p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1.5, -0.3125, 1.5)
          swait()
        end
        p:Remove()
      end), pc, 5)
      local pc = Instance.new("Part", workspace)
      pc.BrickColor = BrickColor:White()
      local m = Instance.new("SpecialMesh", pc)
      m.Scale = Vector3.new(2, 11, 2)
      pc.Anchored = true
      pc.CanCollide = false
      pc.Size = Vector3.new(0.2, 0.2, 0.2)
      pc.Mesh.MeshType = "FileMesh"
      pc.Anchored = true
      pc.CanCollide = false
      pc.Parent = workspace
      pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=489415572"
      pc.Name = "Shockwave"
      game:GetService("Debris"):AddItem(pc, 5)
      pc.CFrame = CFrame.new(drawline_b(RootPart.Position + RootPart.CFrame.lookVector * 2, RootPart.Position + RootPart.CFrame.lookVector * 2 - Vector3.new(0, 30, 0))) + Vector3.new(0, 4.2, 0)
      coroutine.resume(coroutine.create(function(p, x)
        for i = 1, 18 do
          p.Transparency = 0.5 + i / 36
          p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(1 + i), 0) - Vector3.new(0, 0.2777777777777778, 0)
          p.Mesh.Scale = p.Mesh.Scale + Vector3.new(0.7, -0.5555555555555556, 0.7)
          swait()
        end
        p:Remove()
      end), pc, 5)
      MagniDamage(Torso, 27.5, 0, 8.5, 30, "Stomp", Torso, 0, 1, 20, nil, nil, true)
    end
    for i = 1, 3 do
      swait()
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      if Stagger.Value == true or Stun.Value >= StunT.Value or Stun.Value == true or Unstable.Value == true or Suppressed.Value == true then
        break
      end
    end
    dec.Parent = nil
    attack = false
  end
end
RightShoulderC0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RightShoulderC1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
LeftShoulderC0 = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LeftShoulderC1 = CFrame.new(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RightHipC0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RightHipC1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
LeftHipC0 = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LeftHipC1 = CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
NeckC0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
NeckC1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
RootJointC0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
RootJointC1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
ignoretab2 = {}
function drawline_b(pos, pos2)
  local par, loc, normal
  for i = 1, 100 do
    par, loc, normal = workspace:FindPartOnRayWithIgnoreList(Ray.new(pos, -(pos - pos2)), ignoretab2)
    if par then
      if par.CanCollide == false or par.Parent:FindFirstChild("Humanoid") ~= nil or par.Parent.ClassName == "Tool" or par.Parent:IsA("Accoutrement") or par:IsDescendantOf(game.Players.LocalPlayer) then
        table.insert(ignoretab2, par)
      else
        return loc
      end
    else
      return loc
    end
  end
  warn("This isn't working.")
  return Vector3.new(0, 0, 0)
end
function drawline_a(pos, pos2)
  local par, loc, normal
  for i = 1, 100 do
    par, loc, normal = workspace:FindPartOnRayWithIgnoreList(Ray.new(pos, -(pos - pos2)), ignoretab2)
    if par then
      if par.CanCollide == false or par.Name == "Ball" or par.Parent:FindFirstChild("Humanoid") ~= nil or par.Parent.ClassName == "Tool" or par.Parent.className == "Hat" or par:IsDescendantOf(game.Players.LocalPlayer) then
        table.insert(ignoretab2, par)
      else
        return par, loc, normal
      end
    else
      return par, loc, normal
    end
  end
  warn("This isn't working.")
  return Vector3.new(0, 0, 0)
end
function do4()
  if attack == true then
    return
  end
  if attack == true or equipped == false or Stunned.Value == true or Stagger.Value == true or Unstable.Value == true or Suppressed.Value == true then
    return
  end
  if cooldowns[4] >= cooldownmax and mana.Value >= 40 then
    doingbust = true
    attack = true
    mana.Value = mana.Value - 40
    cooldowns[4] = 0
    Humanoid.AutoRotate = false
    do
      local cdir = Character.HumanoidRootPart.CFrame.lookVector
      cdir = Vector3.new(cdir.x, 0, cdir.z)
      local dec2 = Instance.new("NumberValue", Decrease)
      dec2.Name = "DecreaseMvmt"
      dec2.Value = 10
      local cld2 = Instance.new("NumberValue", Decrease)
      cld2.Name = "DecreaseKBR"
      cld2.Value = 1
      t = tick()
      UltVal.Value = true
      local rp1 = Character["Tortoise Shell"]["Right Part17"]
      local rp2 = Character["Tortoise Shell"]["Right Part18"]
      local rb1 = rp1:clone()
      rb1.Name = "TempPart"
      rb1.Parent = rp1.Parent
      rb1.Mesh.Offset = Vector3.new(0, 0.2, 0)
      rb1.TopSurface = 0
      rb1.BottomSurface = 0
      local rbw1 = Instance.new("Weld", rp1)
      rbw1.Part0 = rp1
      rbw1.Part1 = rb1
      rb1.Mesh.Scale = rb1.Mesh.Scale - Vector3.new(0.15, 0, 0.15)
      rb1.BrickColor = BrickColor.new("Medium stone grey")
      local rb2 = Instance.new("Part", rp1.Parent)
      rb2.Size = Vector3.new(0.2, 0.2, 0.2)
      rb2.CanCollide = false
      rb2.BrickColor = BrickColor:Black()
      rb2.TopSurface = 0
      rb2.BottomSurface = 0
      local m = Instance.new("BlockMesh", rb2)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local rbw2 = Instance.new("Weld", rb1)
      rbw2.Part0 = rp1
      rbw2.Part1 = rb2
      local rb3 = Instance.new("Part", rp1.Parent)
      rb3.Size = Vector3.new(0.2, 0.2, 0.2)
      rb3.CanCollide = false
      rb3.BrickColor = BrickColor:Black()
      rb3.TopSurface = 0
      rb3.BottomSurface = 0
      local m = Instance.new("BlockMesh", rb3)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local rbw3 = Instance.new("Weld", rb1)
      rbw3.Part0 = rp1
      rbw3.Part1 = rb3
      rbw3.C0 = CFrame.Angles(0, math.rad(90), 0)
      local rb4 = Instance.new("Part", rp1.Parent)
      rb4.Size = Vector3.new(0.2, 0.2, 0.2)
      rb4.CanCollide = false
      rb4.BrickColor = BrickColor:Black()
      local m = Instance.new("BlockMesh", rb4)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local rbw4 = Instance.new("Weld", rb1)
      rbw4.Part0 = rp1
      rbw4.Part1 = rb4
      rbw4.C0 = CFrame.Angles(0, math.rad(45), 0)
      rb4.TopSurface = 0
      rb4.BottomSurface = 0
      local rb5 = Instance.new("Part", rp1.Parent)
      rb5.Size = Vector3.new(0.2, 0.2, 0.2)
      rb5.CanCollide = false
      rb5.BrickColor = BrickColor:Black()
      local m = Instance.new("BlockMesh", rb5)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local rbw5 = Instance.new("Weld", rb1)
      rbw5.Part0 = rp1
      rbw5.Part1 = rb5
      rbw5.C0 = CFrame.Angles(0, math.rad(135), 0)
      rb5.TopSurface = 0
      rb5.BottomSurface = 0
      local lp1 = Character["Tortoise Shell"]["Left Part17"]
      local lp2 = Character["Tortoise Shell"]["Left Part18"]
      local lb1 = lp1:clone()
      lb1.Name = "TempPart"
      lb1.Parent = lp1.Parent
      lb1.Mesh.Offset = Vector3.new(0, 0.2, 0)
      local lbw1 = Instance.new("Weld", lp1)
      lbw1.Part0 = lp1
      lbw1.Part1 = lb1
      lb1.Mesh.Scale = lb1.Mesh.Scale - Vector3.new(0.15, 0, 0.15)
      lb1.BrickColor = BrickColor.new("Medium stone grey")
      local lb2 = Instance.new("Part", lp1.Parent)
      lb2.Size = Vector3.new(0.2, 0.2, 0.2)
      lb2.CanCollide = false
      lb2.BrickColor = BrickColor:Black()
      local m = Instance.new("BlockMesh", lb2)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local lbw2 = Instance.new("Weld", lb1)
      lbw2.Part0 = lp1
      lbw2.Part1 = lb2
      lb2.TopSurface = 0
      lb2.BottomSurface = 0
      local lb3 = Instance.new("Part", lp1.Parent)
      lb3.Size = Vector3.new(0.2, 0.2, 0.2)
      lb3.CanCollide = false
      lb3.BrickColor = BrickColor:Black()
      local m = Instance.new("BlockMesh", lb3)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local lbw3 = Instance.new("Weld", lb1)
      lbw3.Part0 = lp1
      lbw3.Part1 = lb3
      lbw3.C0 = CFrame.Angles(0, math.rad(90), 0)
      lb3.TopSurface = 0
      lb3.BottomSurface = 0
      local lb4 = Instance.new("Part", lp1.Parent)
      lb4.Size = Vector3.new(0.2, 0.2, 0.2)
      lb4.CanCollide = false
      lb4.BrickColor = BrickColor:Black()
      local m = Instance.new("BlockMesh", lb4)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local lbw4 = Instance.new("Weld", lb1)
      lbw4.Part0 = lp1
      lbw4.Part1 = lb4
      lbw4.C0 = CFrame.Angles(0, math.rad(45), 0)
      lb4.TopSurface = 0
      lb4.BottomSurface = 0
      local lb5 = Instance.new("Part", lp1.Parent)
      lb5.Size = Vector3.new(0.2, 0.2, 0.2)
      lb5.CanCollide = false
      lb5.BrickColor = BrickColor:Black()
      local m = Instance.new("BlockMesh", lb5)
      m.Scale = Vector3.new(3.365, 1, 0.15)
      m.Offset = Vector3.new(0, 0.3, 0)
      local lbw5 = Instance.new("Weld", lb1)
      lbw5.Part0 = lp1
      lbw5.Part1 = lb5
      lbw5.C0 = CFrame.Angles(0, math.rad(135), 0)
      lb5.TopSurface = 0
      lb5.BottomSurface = 0
      local ks = Instance.new("Sound", RootPart)
      ks.Volume = 0.8
      ks.Pitch = 0.9
      ks.SoundId = "rbxassetid://471881922"
      coroutine.resume(coroutine.create(function(p)
        wait()
        p:Play()
      end), ks)
      game:GetService("Debris"):AddItem(ks, 15)
      for i = 1, 16 do
        swait()
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
          break
        end
        if Stagger.Value == true then
          Stagger.Value = false
        end
        if Unstable.Value == true then
          Unstable.Value = false
          Unstable.Timer.Value = 0
        end
        if Stunned.Value == true or Stun.Value >= StunT.Value then
          Stunned.Value = false
          Stun.Value = StunT.Value - 1
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, -0.2, -0.6) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(2)), 0.1 + i * 0.01)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3), 0, 0), 0.1 + i * 0.01)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.5, 0, -0.5) * CFrame.Angles(-math.rad(5), 0, math.rad(85)), 0.1 + i * 0.01)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(20), 0, 0), 0.1 + i * 0.01)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.5, 0, -0.5) * CFrame.Angles(-math.rad(5), 0, -math.rad(85)), 0.1 + i * 0.01)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(20), 0, 0), 0.1 + i * 0.01)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.6, 0.65, 0) * CFrame.Angles(-math.rad(1), 0, math.rad(1)), 0.1 + i * 0.01)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.1, 0.55, 0) * CFrame.Angles(-math.rad(2), 0, math.rad(19)), 0.1 + i * 0.01)
        if i == 6 then
          coroutine.resume(coroutine.create(function()
            local k = Instance.new("Sound", rp1)
            k.Volume = 0.85
            k.SoundId = "rbxassetid://471882065"
            k.Pitch = math.random(95, 105) / 100
            coroutine.resume(coroutine.create(function(p)
              wait()
              p:Play()
            end), k)
            game:GetService("Debris"):AddItem(k, 5)
            local k = Instance.new("Sound", lp1)
            k.Volume = 0.85
            k.SoundId = "rbxassetid://471882065"
            k.Pitch = math.random(95, 105) / 100
            coroutine.resume(coroutine.create(function(p)
              wait()
              p:Play()
            end), k)
            game:GetService("Debris"):AddItem(k, 5)
            local k = Instance.new("Sound", lp1)
            k.Volume = 0.6
            k.SoundId = "rbxassetid://291165237"
            k.Pitch = math.random(95, 105) / 100
            coroutine.resume(coroutine.create(function(p)
              wait()
              p:Play()
              for i = 1, 50 do
                p.Volume = p.Volume * 0.95
                swait()
              end
              p:Stop()
            end), k)
            game:GetService("Debris"):AddItem(k, 5)
            local k = Instance.new("Sound", rp1)
            k.Volume = 0.6
            k.SoundId = "rbxassetid://291165237"
            k.Pitch = math.random(95, 105) / 100
            coroutine.resume(coroutine.create(function(p)
              wait()
              p:Play()
              for i = 1, 50 do
                p.Volume = p.Volume * 0.95
                swait()
              end
              p:Stop()
            end), k)
            game:GetService("Debris"):AddItem(k, 5)
            local re = Instance.new("ParticleEmitter", rp1)
            re.Texture = "http://www.roblox.com/asset/?id=242687290"
            re.Size = NumberSequence.new({
              NumberSequenceKeypoint.new(0, 2),
              NumberSequenceKeypoint.new(1, 6)
            })
            re.Transparency = NumberSequence.new({
              NumberSequenceKeypoint.new(0, 0.66),
              NumberSequenceKeypoint.new(1, 1)
            })
            re.Rate = 120
            re.Rotation = NumberRange.new(-360, 360)
            re.RotSpeed = NumberRange.new(-60, 60)
            re.Speed = NumberRange.new(4, 6)
            re.VelocitySpread = 60
            re.Lifetime = NumberRange.new(0.8, 1.2)
            re.EmissionDirection = "Bottom"
            local le = Instance.new("ParticleEmitter", lp1)
            le.Texture = "http://www.roblox.com/asset/?id=242687290"
            le.Size = NumberSequence.new({
              NumberSequenceKeypoint.new(0, 1.6),
              NumberSequenceKeypoint.new(1, 6)
            })
            le.Transparency = NumberSequence.new({
              NumberSequenceKeypoint.new(0, 0.66),
              NumberSequenceKeypoint.new(1, 1)
            })
            le.Rate = 120
            le.Rotation = NumberRange.new(-360, 360)
            le.RotSpeed = NumberRange.new(-60, 60)
            le.Speed = NumberRange.new(4, 6)
            le.VelocitySpread = 60
            le.Lifetime = NumberRange.new(0.8, 1.2)
            le.EmissionDirection = "Bottom"
            for i = 1, 10 do
              re.Rate = re.Rate - 10
              re.VelocitySpread = re.VelocitySpread - 2
              re.Speed = NumberRange.new(19 - i, 25 - i)
              re.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.5 + i * 0.043),
                NumberSequenceKeypoint.new(1, 1)
              })
              le.Rate = re.Rate - 10
              le.VelocitySpread = re.VelocitySpread - 2
              le.Speed = NumberRange.new(19 - i, 25 - i)
              le.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.5 + i * 0.043),
                NumberSequenceKeypoint.new(1, 1)
              })
              rb1.Mesh.Scale = rb1.Mesh.Scale + Vector3.new(0, 0.16000000000000003, 0)
              rb1.Mesh.Offset = rb1.Mesh.Offset + Vector3.new(0, -0.05375, 0)
              rb2.Mesh.Scale = rb2.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              rb2.Mesh.Offset = rb2.Mesh.Offset + Vector3.new(0, -0.065, 0)
              rb3.Mesh.Scale = rb3.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              rb3.Mesh.Offset = rb3.Mesh.Offset + Vector3.new(0, -0.065, 0)
              rb4.Mesh.Scale = rb4.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              rb4.Mesh.Offset = rb4.Mesh.Offset + Vector3.new(0, -0.065, 0)
              rb5.Mesh.Scale = rb5.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              rb5.Mesh.Offset = rb5.Mesh.Offset + Vector3.new(0, -0.065, 0)
              lb2.Mesh.Scale = lb2.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              lb2.Mesh.Offset = lb2.Mesh.Offset + Vector3.new(0, -0.065, 0)
              lb3.Mesh.Scale = lb3.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              lb3.Mesh.Offset = lb3.Mesh.Offset + Vector3.new(0, -0.065, 0)
              lb4.Mesh.Scale = lb4.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              lb4.Mesh.Offset = lb4.Mesh.Offset + Vector3.new(0, -0.065, 0)
              lb5.Mesh.Scale = lb5.Mesh.Scale + Vector3.new(0, 0.11000000000000001, 0)
              lb5.Mesh.Offset = lb5.Mesh.Offset + Vector3.new(0, -0.065, 0)
              lb1.Mesh.Scale = lb1.Mesh.Scale + Vector3.new(0, 0.16000000000000003, 0)
              lb1.Mesh.Offset = lb1.Mesh.Offset + Vector3.new(0, -0.05375, 0)
              rp1.Mesh.Offset = rp1.Mesh.Offset - Vector3.new(0, 0.06999999999999999, 0)
              rp2.Mesh.Scale = rp2.Mesh.Scale + Vector3.new(0, 0.25, 0)
              rp2.Mesh.Offset = rp2.Mesh.Offset - Vector3.new(0, 0.045000000000000005, 0)
              lp1.Mesh.Offset = lp1.Mesh.Offset - Vector3.new(0, 0.06999999999999999, 0)
              lp2.Mesh.Scale = lp2.Mesh.Scale + Vector3.new(0, 0.25, 0)
              lp2.Mesh.Offset = lp2.Mesh.Offset - Vector3.new(0, 0.045000000000000005, 0)
              swait()
            end
            repeat
              wait()
              if bustTarget ~= nil then
                re.Enabled = false
                game:GetService("Debris"):AddItem(re, 3)
                le.Enabled = false
                game:GetService("Debris"):AddItem(le, 3)
              end
            until attack == false
            re.Enabled = false
            game:GetService("Debris"):AddItem(re, 3)
            le.Enabled = false
            game:GetService("Debris"):AddItem(le, 3)
            for i = 1, 10 do
              rb1.Mesh.Scale = rb1.Mesh.Scale - Vector3.new(0, 0.16000000000000003, 0)
              rb1.Mesh.Offset = rb1.Mesh.Offset - Vector3.new(0, -0.05375, 0)
              lb1.Mesh.Scale = lb1.Mesh.Scale - Vector3.new(0, 0.16000000000000003, 0)
              lb1.Mesh.Offset = lb1.Mesh.Offset - Vector3.new(0, -0.05375, 0)
              rb2.Mesh.Scale = rb2.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              rb2.Mesh.Offset = rb2.Mesh.Offset - Vector3.new(0, -0.065, 0)
              rb3.Mesh.Scale = rb3.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              rb3.Mesh.Offset = rb3.Mesh.Offset - Vector3.new(0, -0.065, 0)
              rb4.Mesh.Scale = rb4.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              rb4.Mesh.Offset = rb4.Mesh.Offset - Vector3.new(0, -0.065, 0)
              rb5.Mesh.Scale = rb5.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              rb5.Mesh.Offset = rb5.Mesh.Offset - Vector3.new(0, -0.065, 0)
              lb2.Mesh.Scale = lb2.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              lb2.Mesh.Offset = lb2.Mesh.Offset - Vector3.new(0, -0.065, 0)
              lb3.Mesh.Scale = lb3.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              lb3.Mesh.Offset = lb3.Mesh.Offset - Vector3.new(0, -0.065, 0)
              lb4.Mesh.Scale = lb4.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              lb4.Mesh.Offset = lb4.Mesh.Offset - Vector3.new(0, -0.065, 0)
              lb5.Mesh.Scale = lb5.Mesh.Scale - Vector3.new(0, 0.11000000000000001, 0)
              lb5.Mesh.Offset = lb5.Mesh.Offset - Vector3.new(0, -0.065, 0)
              rp1.Mesh.Offset = rp1.Mesh.Offset + Vector3.new(0, 0.06999999999999999, 0)
              rp2.Mesh.Scale = rp2.Mesh.Scale - Vector3.new(0, 0.25, 0)
              rp2.Mesh.Offset = rp2.Mesh.Offset + Vector3.new(0, 0.045000000000000005, 0)
              lp1.Mesh.Offset = lp1.Mesh.Offset + Vector3.new(0, 0.06999999999999999, 0)
              lp2.Mesh.Scale = lp2.Mesh.Scale - Vector3.new(0, 0.25, 0)
              lp2.Mesh.Offset = lp2.Mesh.Offset + Vector3.new(0, 0.045000000000000005, 0)
              swait()
            end
            rb1:Destroy()
            rbw1:Destroy()
            lb1:Destroy()
            lbw1:Destroy()
            rb2:Destroy()
            rb3:Destroy()
            rb4:Destroy()
            rb5:Destroy()
            lb2:Destroy()
            lb3:Destroy()
            lb4:Destroy()
            lb5:Destroy()
          end))
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          break
        end
      end
      swait()
      if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
        UltVal.Value = false
        dec2:Destroy()
        doingbust = false
        attack = false
        bustTarget = nil
        Humanoid.AutoRotate = true
        return
      end
      for i = 1, 60 do
        swait()
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
          break
        end
        if Stagger.Value == true then
          Stagger.Value = false
        end
        if Unstable.Value == true then
          Unstable.Value = false
          Unstable.Timer.Value = 0
        end
        if Stunned.Value == true or Stun.Value >= StunT.Value then
          Stunned.Value = false
          Stun.Value = StunT.Value - 1
        end
        lwld8.C0 = lwld8.C0 * euler(0, math.rad(i), 0)
        rwld8.C0 = rwld8.C0 * euler(0, math.rad(i), 0)
        rwld17.C0 = euler(1.57, 0, -math.rad(i * (1 + i / 6))) * cf(0, 0.6, -0.03)
        lwld17.C0 = euler(1.57, 0, math.rad(i * (1 + i / 6))) * cf(0, 0.6, -0.03)
        if i % 8 == 0 and i <= 48 or i == 1 then
          local pc = Instance.new("Part", workspace)
          pc.BrickColor = BrickColor:White()
          local m = Instance.new("SpecialMesh", pc)
          m.Scale = Vector3.new(2, 2, 2)
          pc.Anchored = true
          pc.CanCollide = false
          pc.Size = Vector3.new(0.2, 0.2, 0.2)
          pc.Mesh.MeshType = "FileMesh"
          pc.Anchored = true
          pc.CanCollide = false
          pc.Parent = workspace
          pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
          pc.Name = "Shockwave"
          game:GetService("Debris"):AddItem(pc, 5)
          pc.CFrame = CFrame.new(drawline_b(RootPart.Position, RootPart.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 0.9, 0))
          coroutine.resume(coroutine.create(function(p, x)
            for i = 1, 25 do
              p.Transparency = 0.66 + i / 73.52941176470588
              p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0) - Vector3.new(0, 0.05, 0)
              p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1 - i * 0.05 + x, -0.1, 1 - i * 0.05 + x)
              swait()
            end
            p:Remove()
          end), pc, i * 0.04)
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.55, -0.1625) * CFrame.Angles(math.rad(-26), math.rad(0), math.rad(2)), 0.08 - i * 0.0015)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(23), 0, 0), 0.08 - i * 0.0015)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.4, 0, 0.2) * CFrame.Angles(-math.rad(5), 0, math.rad(90)) * CFrame.Angles(math.rad(math.random(-i, i) / 97 * i), math.rad(math.random(-i, i) / 117 * i), math.rad(math.random(-i, i) / 110 * i)), 0.03 + i * 0.0015)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(104), 0, 0), 0.08 - i * 0.0015)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.4, 0, 0.2) * CFrame.Angles(-math.rad(5), 0, -math.rad(90)) * CFrame.Angles(math.rad(math.random(-i, i) / 97 * i), math.rad(math.random(-i, i) / 117 * i), math.rad(math.random(-i, i) / 110 * i)), 0.03 + i * 0.0015)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(104), 0, 0), 0.08 - i * 0.0015)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(-0.1, -0.075, 0) * CFrame.Angles(-math.rad(3), 0, -math.rad(13)), 0.08 - i * 0.0015)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0.15, -0.075, 0) * CFrame.Angles(-math.rad(3), 0, math.rad(35)), 0.08 - i * 0.0015)
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          break
        end
      end
      coroutine.resume(coroutine.create(function(p)
        for i = 1, 30 do
          p.Volume = p.Volume * 0.9
          swait()
        end
        p:Stop()
      end), ks)
      if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
        UltVal.Value = false
        dec2:Destroy()
        cld2:Destroy()
        doingbust = false
        attack = false
        bustTarget = nil
        Humanoid.AutoRotate = true
        return
      end
      swait()
      print(tick() - t)
      so("471881954", RootPart, 1, 1)
      busterhit = false
      bustTarget = nil
      local cp = RootPart.CFrame.p
      local vRootPartVelocity = Instance.new("BodyVelocity", RootPart)
      vRootPartVelocity.P = 500
      vRootPartVelocity.maxForce = Vector3.new(53500, 500, 53500)
      local hit = Instance.new("Part")
      hit.Transparency = 1
      hit.CanCollide = false
      hit.Size = Vector3.new(0.2, 0.2, 0.2)
      hit.Anchored = true
      if TimeLocked.Value == true then
        repeat
          game:GetService("RunService").Heartbeat:wait()
        until TimeLocked.Value == false or Suppressed.Value == true
      end
      local vp, mag
      for i = 1, 10 do
        swait()
        if TimeLocked.Value == true then
          repeat
            game:GetService("RunService").Heartbeat:wait()
          until TimeLocked.Value == false or Suppressed.Value == true
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
          break
        end
        if Stagger.Value == true then
          Stagger.Value = false
        end
        if Unstable.Value == true then
          Unstable.Value = false
          Unstable.Timer.Value = 0
        end
        if Stunned.Value == true or Stun.Value >= StunT.Value then
          Stunned.Value = false
          Stun.Value = StunT.Value - 1
        end
        if Rooted.Value == false then
          vRootPartVelocity.velocity = cdir * (47.5 - i * 4.25)
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(2)), 0.35)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5), 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.3, 0, 0.2) * CFrame.Angles(-math.rad(8), 0, math.rad(80)), 0.35)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(60), 0, 0), 0.35)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.3, 0, 0.2) * CFrame.Angles(-math.rad(2), 0, -math.rad(90)), 0.35)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(60), 0, 0), 0.35)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.6, 0.4, 0) * CFrame.Angles(-math.rad(1), 0, math.rad(1)), 0.35)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.1, 0.3, 0) * CFrame.Angles(-math.rad(2), 0, math.rad(5)), 0.35)
        hit.CFrame = RootPart.CFrame + cdir * 1.25 + Vector3.new(0, 1.5, 0)
        if i >= 2 then
          for _, v in pairs(workspace:children()) do
            if v.className == "Model" and v:FindFirstChild("HumanoidRootPart") and v:FindFirstChild("Humanoid") and v:FindFirstChild("Stats") and v.Stats:FindFirstChild("Grabbing") == nil then
              t = v.HumanoidRootPart
              vp = game.Players:GetPlayerFromCharacter(v)
              if vp == nil then
                if v:FindFirstChild("Alignment") then
                  if v.Alignment.Value ~= Player.TeamColor or Player.Neutral == true then
                    mag = (t.Position - hit.Position).magnitude
                    if mag <= 7 then
                      bustTarget = v
                    end
                  end
                else
                  mag = (t.Position - hit.Position).magnitude
                  if mag <= 7 then
                    bustTarget = v
                  end
                end
              elseif vp.TeamColor ~= Player.TeamColor or Player.Neutral == true and vp.Neutral == true and vp ~= Player then
                mag = (t.Position - hit.Position).magnitude
                if mag <= 7 then
                  bustTarget = v
                end
              end
            end
          end
          if bustTarget ~= nil then
            break
          end
        end
        if busterhit == true or 10 <= (RootPart.CFrame.p - cp).magnitude then
          break
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          break
        end
      end
      if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
        UltVal.Value = false
        dec2:Destroy()
        cld2:Destroy()
        doingbust = false
        attack = false
        bustTarget = nil
        vRootPartVelocity:Destroy()
        Humanoid.AutoRotate = true
        return
      end
      if bustTarget == nil then
        if Rooted.Value == false then
          RootPart.Velocity = RootPart.Velocity / 1.2
        end
        vRootPartVelocity:Destroy()
        for i = 1, 15 do
          swait()
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
            break
          end
          if Stagger.Value == true then
            Stagger.Value = false
          end
          if Unstable.Value == true then
            Unstable.Value = false
            Unstable.Timer.Value = 0
          end
          if Stunned.Value == true or Stun.Value >= StunT.Value then
            Stunned.Value = false
            Stun.Value = StunT.Value - 1
          end
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(2)), 0.08)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5), 0, 0), 0.15)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.3, 0, 0.1) * CFrame.Angles(-math.rad(12), 0, math.rad(80)), 0.15)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(63), 0, 0), 0.15)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.3, 0, 0.1) * CFrame.Angles(-math.rad(1), 0, -math.rad(90)), 0.15)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(63), 0, 0), 0.15)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.15, 0.3, 0) * CFrame.Angles(-math.rad(1), math.rad(2), math.rad(11)), 0.05)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.1, 0.2, 0) * CFrame.Angles(-math.rad(2), -math.rad(2), -math.rad(13)), 0.05)
        end
      else
        workspace.CurrentCamera.CameraType = "Track"
        bustTarget.Humanoid.PlatformStand = true
        local geld, geld2
        so("153092304", bustTarget.HumanoidRootPart, 1, 0.8)
        if geld == nil then
          geld = bustTarget.Torso:FindFirstChild("BodyGyro")
          if geld then
            geld:Destroy()
          end
        end
        if geld2 == nil and bustTarget:FindFirstChild("HumanoidRootPart") then
          geld2 = bustTarget.HumanoidRootPart:FindFirstChild("BodyGyro")
          if geld2 then
            geld2:Destroy()
            print("DED")
          end
        end
        local gval = Instance.new("StringValue", bustTarget.Stats)
        gval.Value = Player.Name
        gval.Name = "Grabbed"
        local xs = RootPart.CFrame.p
        RootPart.Anchored = true
        local dir = RootPart.CFrame.lookVector
        dir = Vector3.new(dir.x, 0, dir.z)
        bustTarget.Torso.Anchored = true
        local supp
        if bustTarget:FindFirstChild("Stats") and bustTarget.Stats:FindFirstChild("Suppressed") then
          supp = bustTarget.Stats.Suppressed
        end
        local override
        if supp then
          supp.Value = true
          supp.Timer.Value = 10
          override = Instance.new("BoolValue", supp)
          override.Name = "Override"
        end
        for i = 1, 12 do
          swait()
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
            break
          end
          if Stagger.Value == true then
            Stagger.Value = false
          end
          if Unstable.Value == true then
            Unstable.Value = false
            Unstable.Timer.Value = 0
          end
          if Stunned.Value == true or Stun.Value >= StunT.Value then
            Stunned.Value = false
            Stun.Value = StunT.Value - 1
          end
          RootPart.CFrame = CFrame.new(xs, xs + dir * 5)
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(math.rad(6), math.rad(0), math.rad(2)), 0.08)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5), 0, 0), 0.1)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.3, 0, 0.1) * CFrame.Angles(-math.rad(7), 0, math.rad(88)), 0.1)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(33), 0, 0), 0.1)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.3, 0, 0.1) * CFrame.Angles(-math.rad(1), 0, -math.rad(92)), 0.1)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(33), 0, 0), 0.1)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.15, 0.3, 0) * CFrame.Angles(-math.rad(1), math.rad(2), math.rad(6)), 0.05)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.1, 0.2, 0) * CFrame.Angles(-math.rad(2), -math.rad(2), -math.rad(8)), 0.05)
          bustTarget.Torso.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(-1.5, -2, 0)).p, (Torso.CFrame * CFrame.new(0, 1, 0)).p)
          if supp then
            supp.Value = true
            supp.Timer.Value = 10
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
            break
          end
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          UltVal.Value = false
          dec2:Destroy()
          cld2:Destroy()
          doingbust = false
          attack = false
          vRootPartVelocity:Destroy()
          bustTarget.Torso.Anchored = false
          RootPart.Anchored = false
          bustTarget.Humanoid.PlatformStand = false
          bustTarget = nil
          workspace.CurrentCamera.CameraType = "Custom"
          gval:Destroy()
          Humanoid.AutoRotate = true
          if supp then
            supp.Value = false
            supp.Timer.Value = 0
            override:Destroy()
          end
          return
        end
        so("471881980", RootPart, 1, 0.85)
        local pc = Instance.new("Part", workspace)
        pc.BrickColor = BrickColor:White()
        local m = Instance.new("SpecialMesh", pc)
        m.Scale = Vector3.new(2, 2, 2)
        pc.Anchored = true
        pc.CanCollide = false
        pc.Size = Vector3.new(0.2, 0.2, 0.2)
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        game:GetService("Debris"):AddItem(pc, 5)
        pc.CFrame = CFrame.new(drawline_b(RootPart.Position, RootPart.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 0.9, 0))
        coroutine.resume(coroutine.create(function(p, x)
          for i = 1, 25 do
            p.Transparency = 0.66 + i / 73.52941176470588
            p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0) - Vector3.new(0, 0.05, 0)
            p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1 - i * 0.05 + x, -0.1, 1 - i * 0.05 + x)
            swait()
          end
          p:Remove()
        end), pc, 5)
        local xc = 0
        for i = 1, 10 do
          if geld == nil then
            geld = bustTarget.Torso:FindFirstChild("BodyGyro")
            if geld then
              geld:Destroy()
            end
          end
          if geld2 == nil and bustTarget:FindFirstChild("HumanoidRootPart") then
            geld2 = bustTarget.HumanoidRootPart:FindFirstChild("BodyGyro")
            if geld2 then
              geld2:Destroy()
              print("DED")
            end
          end
          xc = xc + 3 ^ (1 + i * 0.08)
          RootPart.CFrame = CFrame.new(xs + Vector3.new(0, xc, 0), xs + Vector3.new(0, xc, 0) + dir * 5)
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(-math.rad(5), math.rad(0), math.rad(0)), 0.125)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20), 0, 0), 0.125)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, math.rad(50)), 0.125)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(7), 0, 0), 0.125)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, -math.rad(50)), 0.125)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(7), 0, 0), 0.125)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(9), math.rad(2), -math.rad(6)), 0.125)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(9), -math.rad(2), math.rad(5)), 0.125)
          bustTarget.Torso.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(-1.5, -2, 0)).p, (Torso.CFrame * CFrame.new(0, 1, 0)).p)
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
            break
          end
          if Stagger.Value == true then
            Stagger.Value = false
          end
          if Unstable.Value == true then
            Unstable.Value = false
            Unstable.Timer.Value = 0
          end
          if Stunned.Value == true or Stun.Value >= StunT.Value then
            Stunned.Value = false
            Stun.Value = StunT.Value - 1
          end
          if supp then
            supp.Value = true
            supp.Timer.Value = 10
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
            break
          end
          swait()
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          UltVal.Value = false
          dec2:Destroy()
          cld2:Destroy()
          doingbust = false
          attack = false
          vRootPartVelocity:Destroy()
          bustTarget.Torso.Anchored = false
          RootPart.Anchored = false
          bustTarget.Humanoid.PlatformStand = false
          bustTarget = nil
          Humanoid.AutoRotate = true
          workspace.CurrentCamera.CameraType = "Custom"
          gval:Destroy()
          if supp then
            supp.Value = false
            supp.Timer.Value = 0
            override:Destroy()
          end
          return
        end
        for i = 10, 13 do
          xc = xc + 3 ^ (1 + i * 0.08)
          if geld == nil then
            geld = bustTarget.Torso:FindFirstChild("BodyGyro")
            if geld then
              geld:Destroy()
            end
          end
          if geld2 == nil and bustTarget:FindFirstChild("HumanoidRootPart") then
            geld2 = bustTarget.HumanoidRootPart:FindFirstChild("BodyGyro")
            if geld2 then
              geld2:Destroy()
              print("DED")
            end
          end
          RootPart.CFrame = CFrame.new(xs + Vector3.new(0, xc, 0), xs + Vector3.new(0, xc, 0) + dir * 5)
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(-math.rad(24), math.rad(0), math.rad(0)), 0.2)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(20), 0, 0), 0.15)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, math.rad(205)), 0.15)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(7), 0, 0), 0.15)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, -math.rad(205)), 0.15)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(7), 0, 0), 0.15)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(4), math.rad(5), math.rad(6)), 0.15)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(4), -math.rad(5), math.rad(37)), 0.15)
          bustTarget.Torso.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(-1.5, -2, 0)).p, (Torso.CFrame * CFrame.new(0, 1, 0)).p)
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if supp then
            supp.Value = true
            supp.Timer.Value = 10
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
            break
          end
          swait()
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          UltVal.Value = false
          dec2:Destroy()
          cld2:Destroy()
          doingbust = false
          attack = false
          vRootPartVelocity:Destroy()
          bustTarget.Torso.Anchored = false
          RootPart.Anchored = false
          bustTarget.Humanoid.PlatformStand = false
          bustTarget = nil
          Humanoid.AutoRotate = true
          workspace.CurrentCamera.CameraType = "Custom"
          gval:Destroy()
          if supp then
            supp.Value = false
            supp.Timer.Value = 0
            override:Destroy()
          end
          return
        end
        for i = 1, 24 do
          xc = xc + 9 - i * 0.5
          RootPart.CFrame = CFrame.new(xs + Vector3.new(0, xc, 0), xs + Vector3.new(0, xc, 0) + dir * 5)
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(-math.rad(36), math.rad(0), math.rad(0)), 0.1)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(25), 0, 0), 0.125)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, math.rad(208)), 0.125)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(7), 0, 0), 0.125)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, -math.rad(208)), 0.125)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(7), 0, 0), 0.125)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(5), math.rad(5), math.rad(8)), 0.125)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(5), -math.rad(5), math.rad(40)), 0.125)
          bustTarget.Torso.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(-1.5, -2, 0)).p, (Torso.CFrame * CFrame.new(0, 1, 0)).p)
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
            break
          end
          if Stagger.Value == true then
            Stagger.Value = false
          end
          if Unstable.Value == true then
            Unstable.Value = false
            Unstable.Timer.Value = 0
          end
          if Stunned.Value == true or Stun.Value >= StunT.Value then
            Stunned.Value = false
            Stun.Value = StunT.Value - 1
          end
          if supp then
            supp.Value = true
            supp.Timer.Value = 10
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
            break
          end
          swait()
        end
        print(xc)
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          UltVal.Value = false
          dec2:Destroy()
          cld2:Destroy()
          doingbust = false
          attack = false
          vRootPartVelocity:Destroy()
          bustTarget.Torso.Anchored = false
          RootPart.Anchored = false
          bustTarget.Humanoid.PlatformStand = false
          bustTarget = nil
          Humanoid.AutoRotate = true
          workspace.CurrentCamera.CameraType = "Custom"
          gval:Destroy()
          if supp then
            supp.Value = false
            supp.Timer.Value = 0
            override:Destroy()
          end
          return
        end
        so("471882099", RootPart, 1, 1)
        for i = 1, 10 do
          if geld == nil then
            geld = bustTarget.Torso:FindFirstChild("BodyGyro")
            if geld then
              geld:Destroy()
            end
          end
          if geld2 == nil and bustTarget:FindFirstChild("HumanoidRootPart") then
            geld2 = bustTarget.HumanoidRootPart:FindFirstChild("BodyGyro")
            if geld2 then
              geld2:Destroy()
            end
          end
          RootPart.CFrame = CFrame.new(xs + Vector3.new(0, xc, 0), xs + Vector3.new(0, xc, 0) + dir * 5) * CFrame.Angles(-math.rad(21.6 * i), 0, 0)
          RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(-math.rad(36), math.rad(0), math.rad(0)), 0.5)
          Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(35), 0, 0), 0.15)
          RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.3, 0, 0.1) * CFrame.Angles(-math.rad(12), 0, math.rad(180)), 0.15)
          RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(13), 0, 0), 0.15)
          LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.3, 0, 0.1) * CFrame.Angles(-math.rad(1), 0, -math.rad(180)), 0.15)
          LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(13), 0, 0), 0.15)
          RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.15, 0.3, 0) * CFrame.Angles(-math.rad(1), math.rad(2), math.rad(11)), 0.15)
          LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.1, 0.2, 0) * CFrame.Angles(-math.rad(2), -math.rad(2), -math.rad(13)), 0.15)
          bustTarget.Torso.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(-1.5, -2, 0)).p, (Torso.CFrame * CFrame.new(0, 1, 0)).p)
          xc = xc - 1.2 * i - i
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
            break
          end
          if Stagger.Value == true then
            Stagger.Value = false
          end
          if Unstable.Value == true then
            Unstable.Value = false
            Unstable.Timer.Value = 0
          end
          if Stunned.Value == true or Stun.Value >= StunT.Value then
            Stunned.Value = false
            Stun.Value = StunT.Value - 1
          end
          if supp then
            supp.Value = true
            supp.Timer.Value = 10
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
            break
          end
          swait()
        end
        if Suppressed.Value == true and Suppressed:FindFirstChild("Override") or 0 >= Humanoid.Health then
          UltVal.Value = false
          dec2:Destroy()
          cld2:Destroy()
          doingbust = false
          attack = false
          vRootPartVelocity:Destroy()
          bustTarget.Torso.Anchored = false
          RootPart.Anchored = false
          bustTarget.Humanoid.PlatformStand = false
          bustTarget = nil
          Humanoid.AutoRotate = true
          workspace.CurrentCamera.CameraType = "Custom"
          gval:Destroy()
          if supp then
            supp.Value = false
            supp.Timer.Value = 0
            override:Destroy()
          end
          return
        end
        for i = 1, 2 do
          xc = xc - 13
          RootPart.CFrame = CFrame.new(xs + Vector3.new(0, xc, 0), xs + Vector3.new(0, xc, 0) + dir * 5) * CFrame.Angles(-math.rad(217), 0, 0)
          bustTarget.Torso.CFrame = CFrame.new((RightArm.CFrame * CFrame.new(-1.5, -2, 0)).p, (Torso.CFrame * CFrame.new(0, 1, 0)).p)
          if TimeLocked.Value == true then
            repeat
              game:GetService("RunService").Heartbeat:wait()
            until TimeLocked.Value == false or Suppressed.Value == true
          end
          if Suppressed.Value == true and Suppressed:FindFirstChild("Override") then
            break
          end
          if Stagger.Value == true then
            Stagger.Value = false
          end
          if Unstable.Value == true then
            Unstable.Value = false
            Unstable.Timer.Value = 0
          end
          if Stunned.Value == true or Stun.Value >= StunT.Value then
            Stunned.Value = false
            Stun.Value = StunT.Value - 1
          end
          if supp then
            supp.Value = true
            supp.Timer.Value = 10
          end
          swait()
        end
        RootJoint.C0 = clerp(RootJoint.C0, RootJointC0 * CFrame.new(0, 0.2, -0.3) * CFrame.Angles(-math.rad(180), math.rad(0), math.rad(0)), 1)
        Neck.C0 = clerp(Neck.C0, NeckC0 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(35), 0, 0), 0.15)
        RW.C0 = clerp(RW.C0, RightShoulderC0 * CFrame.new(0.3, 0, 0.1) * CFrame.Angles(-math.rad(12), 0, math.rad(180)), 0.15)
        RW.C1 = clerp(RW.C1, RightShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(13), 0, 0), 0.15)
        LW.C0 = clerp(LW.C0, LeftShoulderC0 * CFrame.new(-0.3, 0, 0.1) * CFrame.Angles(-math.rad(1), 0, -math.rad(180)), 0.15)
        LW.C1 = clerp(LW.C1, LeftShoulderC1 * CFrame.new(0, 0, 0) * CFrame.Angles(-math.rad(13), 0, 0), 0.15)
        RH.C0 = clerp(RH.C0, RightHipC0 * CFrame.new(0.15, 0.3, 0) * CFrame.Angles(-math.rad(1), math.rad(2), math.rad(11)), 0.15)
        LH.C0 = clerp(LH.C0, LeftHipC0 * CFrame.new(-0.1, 0.2, 0) * CFrame.Angles(-math.rad(2), -math.rad(2), -math.rad(13)), 0.15)
        RootPart.CFrame = CFrame.new(xs, xs + dir * 5)
        bustTarget.Torso.CFrame = CFrame.new(xs + dir * 7, xs)
        Damagefunc(bustTarget.Torso, 0, 50, 0, 10, RootPart, 0, "Normal", 0, false, false, false)
        so("471882019", RootPart, 1, 0.85)
        so("314970799", RootPart, 0.8, 0.9)
        so("341301373", RootPart, 0.4, 1.05)
        RootPart.Anchored = false
        bustTarget.Torso.Anchored = false
        local xd, sc
        for _, v in pairs(game.Players:children()) do
          if v.Character and v.Character:FindFirstChild("Torso") then
            xd = (v.Character.Torso.Position - xs).magnitude
            if xd <= 100 then
              sc = script.CamShake:clone()
              sc.intensity.Value = 52 - xd / 2
              sc.times.Value = 45
              sc.Disabled = false
              sc.Parent = v.Character
            end
          end
        end
        bustTarget.Humanoid.PlatformStand = false
        if supp then
          supp.Value = false
          supp.Timer.Value = 0.5
          override:Destroy()
        end
        local pc = Instance.new("Part", workspace)
        pc.BrickColor = BrickColor:White()
        local m = Instance.new("SpecialMesh", pc)
        m.Scale = Vector3.new(20, 6, 20)
        pc.Anchored = true
        pc.CanCollide = false
        pc.Size = Vector3.new(0.2, 0.2, 0.2)
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        game:GetService("Debris"):AddItem(pc, 5)
        pc.CFrame = CFrame.new(drawline_b(RootPart.Position, RootPart.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 2.5, 0))
        coroutine.resume(coroutine.create(function(p, x)
          for i = 1, 20 do
            p.Transparency = 0.5 + i / 40
            p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0) - Vector3.new(0, 0.1, 0)
            p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1 - i * 0.05 + x, -0.2, 1 - i * 0.05 + x)
            swait()
          end
          p:Remove()
        end), pc, 6)
        local pc = Instance.new("Part", workspace)
        pc.BrickColor = BrickColor:White()
        local m = Instance.new("SpecialMesh", pc)
        m.Scale = Vector3.new(10, 15, 10)
        pc.Anchored = true
        pc.CanCollide = false
        pc.Size = Vector3.new(0.2, 0.2, 0.2)
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        game:GetService("Debris"):AddItem(pc, 5)
        pc.CFrame = CFrame.new(drawline_b(RootPart.Position, RootPart.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 7, 0))
        coroutine.resume(coroutine.create(function(p, x)
          for i = 1, 20 do
            p.Transparency = 0.5 + i / 40
            p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0) - Vector3.new(0, 0.2, 0)
            p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1 - i * 0.05 + x, -0.4, 1 - i * 0.05 + x)
            swait()
          end
          p:Remove()
        end), pc, 4.5)
        local pc = Instance.new("Part", workspace)
        pc.BrickColor = BrickColor:White()
        local m = Instance.new("SpecialMesh", pc)
        m.Scale = Vector3.new(5, 34, 5)
        pc.Anchored = true
        pc.CanCollide = false
        pc.Size = Vector3.new(0.2, 0.2, 0.2)
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        game:GetService("Debris"):AddItem(pc, 5)
        pc.CFrame = CFrame.new(drawline_b(RootPart.Position, RootPart.Position - Vector3.new(0, 30, 0)) + Vector3.new(0, 16.5, 0))
        coroutine.resume(coroutine.create(function(p, x)
          for i = 1, 20 do
            p.Transparency = 0.5 + i / 40
            p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(2 + i), 0) - Vector3.new(0, 0.45, 0)
            p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1 - i * 0.05 + x, -0.9, 1 - i * 0.05 + x)
            swait()
          end
          p:Remove()
        end), pc, 3)
        Humanoid:ChangeState("GettingUp")
        wait(0.25)
        workspace.CurrentCamera.CameraType = "Custom"
        gval:Destroy()
      end
      hit:Destroy()
      vRootPartVelocity:Destroy()
      UltVal.Value = false
      Humanoid.AutoRotate = true
      doingbust = false
      attack = false
      dec2:Destroy()
      cld2:Destroy()
    end
  end
end
function DecreaseStat(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    elseif Stat == "Defense" then
      d.Name = "DecreaseDef"
    elseif Stat == "Movement" then
      d.Name = "DecreaseMvmt"
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      elseif Stat == "Defense" then
        if Amount > 0 then
          display = "-Defense"
        else
          display = "+Defense"
        end
      elseif Stat == "Movement" then
        if Amount > 0 then
          display = "-Movement"
        else
          display = "+Movement"
        end
      end
      showDamage(Model, display, "Debuff")
      --workspace.damguiFunc:FireServer(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
function GetDist(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if magni >= mag then
    return true
  else
    return false
  end
end
function MagniDamage(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head
      for _, d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if magni >= mag and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              elseif hitnum == 2 then
                so("199149025", ref, 1, 1)
              elseif hitnum == 3 then
                so("199149072", ref, 1, 1)
              elseif hitnum == 4 then
                so("199149109", ref, 1, 1)
              elseif hitnum == 5 then
                so("199149119", ref, 1, 1)
              end
            end
          end
        end
        if d.className == "Part" then
          head = d
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if magni >= mag and c.Name ~= Player.Name then
              if stun == nil then
                stun = math.random(5, 10)
              end
              local Rang
              if Ranged == false then
                Rang = true
              end
              local stag
              if shbash == true then
                stag = true
              end
              Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
            end
          end
        end
      end
    end
  end
end
function rayCast(Pos, Dir, Max, Ignore)
  local ignore = {
    Ignore,
    NoTarget --workspace.NoTarget
  }
  for _, v in pairs(workspace:children()) do
    if v:IsA("BasePart") or v.className == "UnionOperation" then
      if v.Name == "Effect" or v.Name == "Reference" or v.CanCollide == false then
        table.insert(ignore, v)
      end
    elseif v.className == "Model" and v:FindFirstChild("Humanoid") then
      for _, c in pairs(v:children()) do
        if c.className == "Model" or c:IsA("Accoutrement") then
          table.insert(ignore, c)
        end
      end
    end
  end
  return game:service("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(Pos, Dir.unit * (Max or 999.999)), ignore)
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
function effect(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = (LP.p - point1.p).magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {
      effectsg,
      "Cylinder",
      0.2,
      0.01,
      0,
      0.01,
      effectsmsh
    })
  end
end
local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
function Triangle(a, b, c)
  local edg1 = (c - a):Dot((b - a).unit)
  local edg2 = (a - b):Dot((c - b).unit)
  local edg3 = (b - c):Dot((a - c).unit)
  if edg1 <= (b - a).magnitude and edg1 >= 0 then
    a, b = a, b
  elseif edg2 <= (c - b).magnitude and edg2 >= 0 then
    a, b, c = b, c, a
  elseif edg3 <= (a - c).magnitude and edg3 >= 0 then
    a, b, c = c, a, b
  else
    assert(false, "unreachable")
  end
  local len1 = (c - a):Dot((b - a).unit)
  local len2 = (b - a).magnitude - len1
  local width = (a + (b - a).unit * len1 - c).magnitude
  local maincf = CFrameFromTopBack(a, (b - a):Cross(c - b).unit, -(b - a).unit)
  local list = {}
  if len1 > 0.01 then
    local w1 = Instance.new("WedgePart", m)
    game:GetService("Debris"):AddItem(w1, 5)
    w1.Material = "SmoothPlastic"
    w1.FormFactor = "Custom"
    w1.BrickColor = BrickColor.new("Medium blue")
    w1.Transparency = 0
    w1.Reflectance = 0
    w1.Material = "SmoothPlastic"
    w1.CanCollide = false
    NoOutline(w1)
    local sz = Vector3.new(0.2, width, len1)
    w1.Size = sz
    local sp = Instance.new("SpecialMesh", w1)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
    w1:BreakJoints()
    w1.Anchored = true
    w1.Parent = workspace
    w1.Transparency = 0.7
    table.insert(Effects, {
      w1,
      "Disappear",
      0.05
    })
    w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
    table.insert(list, w1)
  end
  if len2 > 0.01 then
    local w2 = Instance.new("WedgePart", m)
    game:GetService("Debris"):AddItem(w2, 5)
    w2.Material = "SmoothPlastic"
    w2.FormFactor = "Custom"
    w2.BrickColor = BrickColor.new("Medium blue")
    w2.Transparency = 0
    w2.Reflectance = 0
    w2.Material = "SmoothPlastic"
    w2.CanCollide = false
    NoOutline(w2)
    local sz = Vector3.new(0.2, width, len2)
    w2.Size = sz
    local sp = Instance.new("SpecialMesh", w2)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
    w2:BreakJoints()
    w2.Anchored = true
    w2.Parent = workspace
    w2.Transparency = 0.7
    table.insert(Effects, {
      w2,
      "Disappear",
      0.05
    })
    w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
    table.insert(list, w2)
  end
  return unpack(list)
end
function MagicBlock(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {
      prt,
      "Block1",
      delay,
      x3,
      y3,
      z3,
      msh
    })
  elseif Type == 2 then
    table.insert(Effects, {
      prt,
      "Block2",
      delay,
      x3,
      y3,
      z3,
      msh
    })
  end
end
function MagicCircle(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function MagicRing(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * cf(x2, y2, z2)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function MagicCylinder(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function ClangEffect(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "CylinderClang",
    duration,
    decrease,
    size,
    power,
    prt.CFrame,
    nil
  })
end
function MagicWave(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Cylinder",
    delay,
    x3,
    y3,
    z3,
    msh
  })
end
function MagicIcicle(brickcolor, cframe, x1, y1, z1, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("SpecialMesh", prt, "FileMesh", "9756362", vt(0, 0, 0), vt(x1, y1, z1))
  for i = 1, 2 do
    BreakEffect(brickcolor, prt.CFrame * cf(0, 4, 0), math.random(20, 80) / 100, math.random(2, 10), math.random(20, 80) / 100)
  end
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Ice",
    delay,
    msh,
    1,
    0.2
  })
end
function BreakEffect(brickcolor, cframe, x1, y1, z1)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  local num = math.random(10, 50) / 1000
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {
    prt,
    "Shatter",
    num,
    prt.CFrame,
    math.random() - math.random(),
    0,
    math.random(50, 100) / 100
  })
end
function Clone()
  for _, v in pairs(Torso.Parent:children()) do
    if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
      local c = part(3, workspace, 0, 0.5, v.BrickColor, "Effect", v.Size)
      c.Anchored = true
      c.CFrame = v.CFrame
      game:GetService("Debris"):AddItem(c, 5)
      if v.Name == "Head" then
        cmsh = mesh("SpecialMesh", c, "Head", "nil", vt(0, 0, 0), v.Mesh.Scale)
      end
      table.insert(Effects, {
        c,
        "Disappear",
        0.05
      })
    end
  end
end
function Damagefunc(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration, Sound, thed)
  if hit.Parent == nil then
    return
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true and hit ~= hitbox and hit ~= hitbox2 then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    elseif hitnum == 2 then
      so("199149025", ref, 1, 1)
    elseif hitnum == 3 then
      so("199149072", ref, 1, 1)
    elseif hitnum == 4 then
      so("199149109", ref, 1, 1)
    elseif hitnum == 5 then
      so("199149119", ref, 1, 1)
    end
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return
      end
    end
    if doingbust == true or grabbing == true then
      so("200632821", rprt7, 1, 1)
      busterhit = true
      bustTarget = hit.Parent
    end
    if Sound == "Shatter" then
      so("199146069", hit, 1, 1)
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    Damage = (maxim * 10 + math.floor(math.random(-maxim, maxim) / 2)) * Atk.Value
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      invis = Stats:findFirstChild("Invisibility")
      isinvis = Stats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true and doingbust == false and grabbing == false then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        Damage = Damage / Stats.Defense.Value
        if Damage <= 30 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          elseif hitnum == 2 then
            so("199149338", hit, 1, 1)
          elseif hitnum == 3 then
            so("199149367", hit, 1, 1)
          elseif hitnum == 4 then
            so("199149409", hit, 1, 1)
          elseif hitnum == 5 then
            so("199149452", hit, 1, 1)
          end
        elseif ranged == false or ranged == nil and blocked ~= true then
          hitnum = math.random(1, 6)
          if hitnum == 1 then
            so("199149137", hit, 1, 1)
          elseif hitnum == 2 then
            so("199149186", hit, 1, 1)
          elseif hitnum == 3 then
            so("199149221", hit, 1, 1)
          elseif hitnum == 4 then
            so("199149235", hit, 1, 1)
          elseif hitnum == 5 then
            so("199149269", hit, 1, 1)
          elseif hitnum == 6 then
            so("199149297", hit, 1, 1)
          end
        end
        if not (Damage <= 30) or staghit == true then
        end
      end
      --workspace.stunFunc:FireServer(hit.Parent, incstun, blocked)
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      --workspace.damguiFunc:FireServer(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        elseif hitnum == 2 then
          so("199148947", hit, 1, 1)
        end
      end
    else
      if DecreaseState == "Defense" then
        print("!")
        DecreaseStat(Character, "Defense", -0.1, 300)
      end
      coroutine.resume(coroutine.create(function(Hum, Dam)
        CurrentHealth = Hum.Health
        Hum:TakeDamage(Dam / 10)--damageFunc:InvokeServer(h, Damage / 10)
      end), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      --workspace.damguiFunc:FireServer(hit.Parent, Damage, "Damage")
      if DecreaseState ~= nil then
        if DecreaseState == "Shatter" then
          DecreaseStat(hit.Parent, "Movement", DecreaseAmount, Duration)
          DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
        else
          DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
        end
      end
      if Type == "Knockdown" then
        local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
        --workspace.kbFunc:FireServer(hit, angle * knockback)
      elseif Type == "Shatter" then
        for i = 1, 10 do
          BreakEffect(BrickColor.new("Cyan"), hit.CFrame, math.random(20, 80) / 100, math.random(2, 10), math.random(20, 80) / 100)
        end
      elseif Type == "Knockdown2" then
        hum = hit.Parent.Humanoid
        local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
        --workspace.kbFunc:FireServer(hit, angle * knockback)
      elseif Type == "Normal" then
        local vp
        if KnockbackType == 1 then
          vp = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
        elseif KnockbackType == 2 then
          vp = Property.CFrame.lookVector * knockback
        end
        --workspace.kbFunc:FireServer(hit, vp)
      elseif Type == "Stomp" then
        DecreaseStat(Character, "Defense", -0.05, 150)
        local fweight = 0
        for _, v in pairs(hit.Parent:children()) do
          if v:IsA("Accoutrement") and v:FindFirstChild("Handle") then
            v.Handle.Velocity = Vector3.new()
            v.Handle.RotVelocity = Vector3.new()
            fweight = fweight + v.Handle:GetMass()
          elseif v:IsA("BasePart") then
            v.Velocity = Vector3.new()
            v.RotVelocity = Vector3.new()
            fweight = fweight + v:GetMass()
            for __, vv in pairs(v:children()) do
              if vv:IsA("BodyMover") and string.find(vv.Name, "Boss") == nil then
                vv:Destroy()
              end
            end
          elseif v.className == "Model" then
            for __, vv in pairs(v:children()) do
              if vv:IsA("BasePart") then
                fweight = fweight + vv:GetMass()
                vv.Velocity = Vector3.new()
                vv.RotVelocity = Vector3.new()
              end
            end
          end
        end
        print(fweight)
        local desvel = (Vector3.new(0, 2.5, 0) + (Property.Position - hit.Position).unit * 2.1).unit
        --workspace.kbFunc:FireServer(hit, desvel * 32.5)
--[[
        if Stats and Stats:FindFirstChild("Root") == nil then
          local skl = script.Root:clone()
          skl.Disabled = false
          skl.Float.Value = fweight
          skl.Parent = Stats:FindFirstChild("Rooted")
        end
]]
      end
    end
    debounce = Instance.new("BoolValue")
    debounce.Name = "DebounceHit"
    debounce.Parent = hit.Parent
    debounce.Value = true
    game:GetService("Debris"):AddItem(debounce, Delay)
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = Player
    c.Parent = h
    game:GetService("Debris"):AddItem(c, 0.5)
    CRIT = false
  end
end
function showDamage(Char, Dealt, Type) -- Nice try though :P
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  if type(Dealt) == "number" then
    Dealt = math.ceil(Dealt)
  end
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    elseif Dealt < 30 then
      damgui.TextColor3 = BrickColor.new("White").Color
    elseif Dealt >= 30 and Dealt < 200 then
      damgui.TextColor3 = BrickColor.new("Bright yellow").Color
    else
      damgui.TextColor3 = BrickColor.new("Really red").Color
      damgui.Font = "SourceSansBold"
    end
  elseif Type == "Debuff" then
    damgui.TextColor3 = BrickColor.new("White").Color
  elseif Type == "Interrupt" then
    damgui.TextColor3 = BrickColor.new("New Yeller").Color
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  elseif Char.Parent:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  elseif Type == "Debuff" or Type == "Interrupt" then
    f.position = c.Position + Vector3.new(0, 5, 0)
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {
    m,
    "showDamage",
    damgui,
    f,
    10,
    1,
    15,
    50,
    100
  })
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
function ob1d(mouse)
  if stance then
    sattack = "ThrowGrab"
    stance = false
  end
  if attack == true or equipped == false or Stunned.Value == true or Stagger.Value == true or Unstable.Value == true or Suppressed.Value == true then
    return
  end
  hold = true
  if combo == 0 then
    combo = 1
    attackone()
  elseif combo == 1 then
    combo = 2
    attacktwo()
  elseif combo == 2 then
    combo = 3
    attackthree()
  elseif combo == 3 then
    combo = 0
    attackfour()
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
function ob1u(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
function key(key)
  if key == "e" and guard == true then
    guard = false
    manualguardend = true
  end
  if key == "z" and shieldroll == true then
    local par, loc = drawline_a(RootPart.Position, RootPart.Position - Vector3.new(0, 6, 0))
    if par ~= nil then
      print(par)
      shieldroll = false
    end
  end
  if key == "x" and stance == true then
    local par, loc = drawline_a(RootPart.Position, RootPart.Position - Vector3.new(0, 5, 0))
    if par ~= nil or stancetime >= 30 then
      sattack = "None"
      stance = false
    end
  end
  if key == "w" and stance == true then
    sattack = "LandGrab"
    stance = false
  end
  if key == "s" and stance == true then
    sattack = "AirGrab"
    stance = false
  end
  if attack == true then
    return
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      animate.Disabled = true
      local anime = Humanoid:LoadAnimation(animate.idle.Animation1)
      anime:Play()
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      animate.Disabled = false
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return
  end
  if key == "e" and guard == false then
    Guard()
  end
  if key == "q" then
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
  if attack == false then
    RecentEnemy.Value = nil
  end
end
function key2(key)
end
function s(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
end
function ds(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Omega loaded.")
local mananum = 0
local blocknum2 = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local Point, LastPoint
local walk = 0
local walkforw = true
passive = Instance.new("NumberValue", Decrease)
passive.Name = "DecreaseKBR"
passive.Value = 0
--[[
kscri = workspace:WaitForChild("GameScript"):WaitForChild("timerHandler"):clone()
kscri.Parent = Stats
kscri.Disabled = false
]]
while true do
  swait()
  if Unstable.Value == true and unst == false then
    if Stun.Value < StunT.Value and Stagger.Value == false and Stunned.Value == false then
      coroutine.resume(coroutine.create(function()
        unst = true
        while attack == true do
          swait()
        end
        UnstableAnim()
        unst = false
      end))
    else
      Unstable.Value = false
      UnstableTime.Value = 0
    end
  end
  if Stagger.Value == true and staggeranim == false then
    if Stunned.Value == false and Stun.Value < StunT.Value and Suppressed.Value == false then
      coroutine.resume(coroutine.create(function()
        staggeranim = true
        while attack == true do
          swait()
        end
        StaggerAnim()
        StaggerHit.Value = false
        Stagger.Value = false
        staggeranim = false
      end))
    else
      Stagger.Value = false
    end
  end
  if Stun.Value >= StunT.Value and stunanim == false then
    if Suppressed.Value == false then
      coroutine.resume(coroutine.create(function()
        stunanim = true
        while attack == true do
          swait()
        end
        StunAnim()
        Stagger.Value = false
        Stun.Value = 0
        stunanim = false
      end))
    else
      Stunned.Value = false
      Stun.Value = StunT - 1
    end
  end
  if TimeLocked.Value == true then
    if Suppressed.Value == false then
      if tlock == false then
        tlock = true
        coroutine.resume(coroutine.create(TimeLock))
      end
    else
      TimeLocked.Value = false
      TimeLocked.Timer.Value = 0
    end
  end
  if Suppressed.Value == true and suppress == false then
    coroutine.resume(coroutine.create(function()
      suppress = true
      while attack == true do
        swait()
      end
      SuppressedAnim()
      suppress = false
    end))
  end
  --if 0 > Mvmt.Value or Stagger.Value == true or Stun.Value >= StunT.Value or StaggerHit.Value == true or Rooted.Value == true or TimeLocked.Value == true or Suppressed.Value == true or Unstable.Value == true then
    --Humanoid.WalkSpeed = 0
  --else
    Humanoid.WalkSpeed = 16 * Mvmt.Value
  --end
  mdec3.Parent = Decrease
  mdec4.Parent = Decrease
  if 0 >= Humanoid.Health then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
        Welds[i].Part0.CanCollide = false
        Welds[i].Part1.CanCollide = false
      else
        Welds[i].Parent = rprt1
      end
    end
  end
  if bustTarget ~= nil and 0 >= Humanoid.Health and bustTarget:findFirstChild("Humanoid") ~= nil then
    bustTarget.Humanoid.PlatformStand = false
  end
  if fnumb < 21 then
    fnumb = fnumb + 1
    if pressedf == false then
      fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
      tellbar.TextTransparency = tellbar.TextTransparency - 0.05
      tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
    else
      if fnumb == 20 then
        fenframe5.Parent = nil
        print("daigui")
      end
      fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
      tellbar.TextTransparency = tellbar.TextTransparency + 0.05
      tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
    end
  end
  if hbwld.Parent == nil then
    hitbox2.Name = "Hitbox"
  else
    hitbox2.Name = "Hitbox2"
  end
  hitbox2.Parent = hitbox.Parent
  hitbox2.Size = hitbox.Size
  hitbox2.CFrame = hitboxCF
  hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
  local stunnum2 = 30
  if stunnum >= stunnum2 then
    if 0 < Stun.Value then
      Stun.Value = Stun.Value - 1
    end
    stunnum = 0
  end
  stunnum = stunnum + 1
  if donum >= 0.5 then
    handidle = true
  elseif donum <= 0 then
    handidle = false
  end
  if handidle == false then
    donum = donum + 0.006
  else
    donum = donum - 0.006
  end
  local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
  local velderp = RootPart.Velocity.y
  hitfloor, posfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
  if equipped == true then
    if attack == false then
      idle = idle + 1
    else
      idle = 0
    end
    if not (idle >= 500) or attack == false then
    end
    if TimeLocked.Value == false and Unstable.Value == false and Stagger.Value == false and Stunned.Value == false and Suppressed.Value == false then
      if Anim == "Walk" then
        if walkforw == true then
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if attack == false then
          Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
          Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.5, 0, 0.5), 0.2)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.8), 0.2)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
        end
      elseif -1 > RootPart.Velocity.y and hitfloor == nil then
        Anim = "Fall"
        if attack == false then
          Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
          Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.2), 0.2)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.3, 0.5, -0.2) * euler(0.7, 0, 0.2), 0.2)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
        end
      elseif torvel < 1 and hitfloor ~= nil then
        Anim = "Idle"
        if attack == false then
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5), 0.3)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.3)
          RW.C0 = clerp(RW.C0, cf(1, 0.5, 0.5) * euler(1.3 - donum / 5, 0, 0.5 + donum / 5), 0.3)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.8 - donum / 5, 0, 0.8 - donum / 5), 0.3)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          RH.C0 = clerp(RH.C0, cf(1.1, -1, 0) * euler(0, 1.07, -0.1), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -2.07, 0.4), 0.2)
        end
      elseif torvel > 2 and torvel < 30 and hitfloor ~= nil then
        Anim = "Walk"
        walk = walk + 1
        if walk >= 15 - 5 * Mvmt.Value then
          walk = 0
          if walkforw == true then
            walkforw = false
          elseif walkforw == false then
            walkforw = true
          end
        end
        if attack == false then
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.5, 0, 0.2), 0.3)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, 0.3), 0.3)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
        end
      elseif torvel >= 30 and hitfloor ~= nil then
        Anim = "Run"
        if attack == false then
          Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.2), 0.4)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1) * euler(0.8, 0, 0.2), 0.4)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.2), 0.4)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, -0.2) * euler(1, 0, 0.2), 0.4)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          RH.C0 = clerp(RH.C0, RHC0 * cf(1, 1, 0.2) * euler(0, -0.2, -0.2), 0.4)
          LH.C0 = clerp(LH.C0, LHC0 * cf(-0.5, 1, 0) * euler(0.2, 0, -1), 0.4)
        end
      end
    end
  end
  if #Effects > 0 then
    for e = 1, #Effects do
      if Effects[e] ~= nil then
        local Thing = Effects[e]
        if Thing ~= nil then
          local Part = Thing[1]
          Mode = Thing[2]
          Delay = Thing[3]
          IncX = Thing[4]
          IncY = Thing[5]
          IncZ = Thing[6]
          if Thing[2] == "CylinderClang" then
            if 1 >= Thing[3] then
              Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
              Thing[7] = Thing[1].CFrame
              effect("New Yeller", 0, Thing[8], Thing[7])
              Thing[8] = Thing[7]
              Thing[3] = Thing[3] + Thing[4]
            else
              Part.Parent = nil
              table.remove(Effects, e)
            end
          end
          if Thing[2] == "showDamage" then
            if Thing[6] < Thing[5] then
              Thing[6] = Thing[6] + 1
            elseif Thing[6] < Thing[7] then
              Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
              Thing[6] = Thing[6] + 1
            elseif Thing[6] < Thing[8] then
              Thing[6] = Thing[6] + 1
            elseif Thing[6] < Thing[9] then
              Thing[6] = Thing[6] + 1
              Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
              Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
              Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
            else
              Thing[1].Parent = nil
              table.remove(Effects, e)
            end
          end
          if Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" then
            if 1 >= Thing[1].Transparency then
              if Thing[2] == "Block1" then
                Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                Mesh = Thing[7]
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Ice" then
                if Thing[6] <= Thing[5] then
                  Thing[6] = Thing[6] + 0.3
                  Thing[1].CFrame = Thing[1].CFrame * cf(0, 1, 0)
                else
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                end
              elseif Thing[2] == "Shatter" then
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                Thing[4] = Thing[4] * cf(0, Thing[7], 0)
                Thing[1].CFrame = Thing[4] * euler(Thing[6], 0, 0)
                Thing[6] = Thing[6] + Thing[5]
              elseif Thing[2] == "Block2" then
                Thing[1].CFrame = Thing[1].CFrame
                Mesh = Thing[7]
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Cylinder" then
                Mesh = Thing[7]
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Blood" then
                Mesh = Thing[7]
                Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Elec" then
                Mesh = Thing[7]
                Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Disappear" then
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              end
            else
              Part.Parent = nil
              table.remove(Effects, e)
            end
          end
        end
      end
    end
  end
  fenbarmana2:TweenSize(UDim2.new(0.4, 0, -4 * mana.Value / 100, 0), nil, 1, 0.4, true)
  fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
  fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
  fenbarhp2:TweenSize(UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0), nil, 1, 0.4, true)
  fenbarhp3.Text = "(" .. math.floor(Humanoid.Health * 10) .. " / " .. math.floor(Humanoid.MaxHealth * 10) .. ")"
  fenbarblock2:TweenSize(UDim2.new(0.4, 0, -4 * BlockVal.Value / 40, 0), nil, 1, 0.4, true)
  fenbarblock2.BackgroundColor3 = Color3.new(0.1, 0.25 + BlockVal.Value / 100, 0.3)
  fenbarblock3.Text = "Shield (" .. math.ceil(BlockVal.Value * 10) / 10 * 10 .. ")"
  fenbarmove1b:TweenSize(UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0), nil, 1, 0.4, true)
  fenbarmove2b:TweenSize(UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0), nil, 1, 0.4, true)
  fenbarmove3b:TweenSize(UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0), nil, 1, 0.4, true)
  fenbarmove4b:TweenSize(UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0), nil, 1, 0.4, true)
  if 1 < Def.Value then
    passive.Value = Def.Value - 1
  end
  passive.Parent = Decrease
  for _, c in pairs(Decrease:children()) do
    if c:findFirstChild("Duration") ~= nil then
      c.Duration.Value = c.Duration.Value - 1
      if 0 >= c.Duration.Value then
        c.Parent = nil
      end
    end
    if c.Name == "DecreaseAtk" then
      decreaseatk = decreaseatk + c.Value
    elseif c.Name == "DecreaseDef" then
      if 0 <= c.Value and c:FindFirstChild("Absolute") == nil then
        decreasedef = decreasedef + c.Value * 0.33
      else
        decreasedef = decreasedef + c.Value
      end
    elseif c.Name == "DecreaseMvmt" then
      if 0 <= c.Value and c:FindFirstChild("Absolute") == nil then
        decreasemvmt = decreasemvmt + c.Value * 0.33
      else
        decreasemvmt = decreasemvmt + c.Value
      end
    elseif c.Name == "DecreaseKBR" then
      if 0 > c.Value then
        decreasekbr = decreasekbr + c.Value
      elseif 0 < c.Value and Unstable.Value == false then
        decreasekbr = decreasekbr + c.Value
      end
    end
  end
  Atk.Value = 1 - decreaseatk
  if 0 >= Atk.Value then
    Atk.Value = 0
  end
  Def.Value = 1 - decreasedef
  if 0 >= Def.Value then
    Def.Value = 0.01
  end
  Mvmt.Value = 1 - decreasemvmt
  if 0 >= Mvmt.Value then
    Mvmt.Value = 0
  end
  if 1 < decreasekbr then
    decreasekbr = 1
  elseif -1 > decreasekbr then
    decreasekbr = -1
  end
  KnockbackResistance.Value = decreasekbr
  decreaseatk = 0
  decreasedef = 0
  decreasemvmt = 0
  decreasekbr = 0
  AtkVal = Atk.Value * 100
  AtkVal = math.floor(AtkVal)
  AtkVal = AtkVal / 100
  fenbardamage.Text = [[
Damage
(]] .. AtkVal * 100 .. "%)"
  DefVal = Def.Value * 100
  DefVal = math.floor(DefVal)
  DefVal = DefVal / 100
  fenbardef.Text = [[
Defense
(]] .. DefVal * 100 .. "%)"
  MvmtVal = Mvmt.Value * 100
  MvmtVal = math.floor(MvmtVal)
  MvmtVal = MvmtVal / 100
  if Rooted.Value == true or Suppressed.Value == true or Unstable.Value == true or TimeLocked.Value == true then
    MvmtVal = 0
  end
  fenbarmove.Text = [[
Walkspeed
(]] .. MvmtVal * 100 .. "%)"
  if Stun.Value >= StunT.Value then
    fenbarstun2:TweenSize(UDim2.new(0.4, 0, -4, 0), nil, 1, 0.4, true)
  else
    fenbarstun2:TweenSize(UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0), nil, 1, 0.4, true)
  end
  fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
  if 100 <= mana.Value then
    mana.Value = 100
  elseif mananum <= 11 and shieldroll == false then
    mananum = mananum + 1
  elseif mananum >= 11 then
    mananum = 0
    mana.Value = mana.Value + 1
  end
  for i = 1, #cooldowns do
    if cooldowns[i] >= cooldownmax then
      cooldowns[i] = cooldownmax
    else
      cooldowns[i] = cooldowns[i] + cooldownsadd[i]
    end
  end
  if blocknum >= 100 then
    blocknum = 100
  elseif blocknum2 <= 6 then
    blocknum2 = blocknum2 + 1
  else
    if guard == false then
    blocknum2 = 0
      blocknum = blocknum + 1
    end
  end
end
